<html>
  <head>
    <title>Starherd</title>
    <meta charset=UTF-8>
    <meta name=description content="Evolving H-R diagram">
    <meta name=keywords content=astronomy>
    <meta name=author content=Xing>
    <meta name=viewport content="width=device-width, initial-scale=1">
    <link rel=stylesheet href=style.css>
    <link rel='shortcut icon' type=image/png href=favicon.png>
    <style>
html, body {
  margin: 0;
  width: 100%;
  height: 100%;
  background: #222;
  color: white;
  font-size: 16px;
}
    </style>
  </head>
  <body>
    <canvas id="hr"></canvas>
    <label>
      <input id="time" type="number" min="0" max="1e8" value="0" step="1">
      <span> million years</span>
    </label>
    <h1>Starherd</h1>
    <p> 
      A stellar evolution visualizer by Xing, based on 
      <a href="https://arxiv.org/abs/astro-ph/0001295">"Comprehensive analytic formulae for stellar evolution as a function of mass and metallicity"</a> 
      by Hurley, Pols &amp; Tout, and 
      <a href="https://ui.adsabs.harvard.edu/abs/1996MNRAS.281..257T/abstract">"Zero-age main-sequence radii and luminosities as analytic functions of mass and metallicity"</a> 
      by Tout, Pols, Eggleton, &amp; Han.
    </p>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script>
"use strict"

const canvas = document.getElementById('hr')

// Math
const random_range = (a, b) => a + (b - a) * Math.random()
const in_range = (a, x, b) => (a <= x) && (x <= b)
const ln = (x) => Math.log(x)
const log10 = (x) => ln(x)/ln(10.0)
const exp = (x) => Math.exp(x)
const exp10 = (x) => Math.pow(10, x)
const abs = (x) => Math.abs(x)
const max = (a,b) => Math.max(a,b)
const min = (a,b) => Math.min(a,b)
const clamp = (a,x,b) => min(max(x,a),b)
const mix = (a,b) => (x) => a*(1-x) + b*x
const lerp = (x) => (x0, x1) => (v0, v1) =>
  (x < x0) ? v0 : (x > x1) ? v1 : mix(v0, v1)((x-x0)/(x1-x0))
const check = (x, ...obj) => isFinite(x) || console.error("check:", x, ...obj)

const sqrt = (x) => Math.sqrt(x)
const cbrt = (x) => Math.cbrt(x)
const int_range = (n) => Array(n).fill(0).map((_, i) => i)
const from_interval = (interval, value) => 
  interval[Object.keys(interval).find(k => parseInt(k) > value)]

// Constants
const PI = Math.PI
const STEFAN = 5.670374419e-8
const L_sun = 3.86e+26 // watts
const R_sun = 6.9634e+8 // meters
const Z_sun = 0.02
const A_H = 1.44e-5 // rate of hydrogen fusion in CNO cycle


const blackbody = {
  1000:"#ff3800",1200:"#ff5300",1400:"#ff6500",1600:"#ff7300",1800:"#ff7e00",2000:"#ff8912",2200:"#ff932c",2400:"#ff9d3f",2600:"#ffa54f",2800:"#ffad5e",3000:"#ffb46b",3200:"#ffbb78",3400:"#ffc184",3600:"#ffc78f",3800:"#ffcc99",4000:"#ffd1a3",4200:"#ffd5ad",4400:"#ffd9b6",4600:"#ffddbe",4800:"#ffe1c6",5000:"#ffe4ce",5200:"#ffe8d5",5400:"#ffebdc",5600:"#ffeee3",5800:"#fff0e9",6000:"#fff3ef",6200:"#fff5f5",6400:"#fff8fb",6600:"#fef9ff",6800:"#f9f6ff",7000:"#f5f3ff",7200:"#f0f1ff",7400:"#edefff",7600:"#e9edff",7800:"#e6ebff",8000:"#e3e9ff",8200:"#e0e7ff",8400:"#dde6ff",8600:"#dae4ff",8800:"#d8e3ff",9000:"#d6e1ff",9200:"#d3e0ff",9400:"#d1dfff",9600:"#cfddff",9800:"#cedcff",10000:"#ccdbff",10200:"#cadaff",10400:"#c9d9ff",10600:"#c7d8ff",10800:"#c6d8ff",11000:"#c4d7ff",11200:"#c3d6ff",11400:"#c2d5ff",11600:"#c1d4ff",11800:"#c0d4ff",12000:"#bfd3ff",12200:"#bed2ff",12400:"#bdd2ff",12600:"#bcd1ff",12800:"#bbd1ff",13000:"#bad0ff",13200:"#b9d0ff",13400:"#b8cfff",13600:"#b7cfff",13800:"#b7ceff",14000:"#b6ceff",14200:"#b5cdff",14400:"#b5cdff",14600:"#b4ccff",14800:"#b3ccff",15000:"#b3ccff",15200:"#b2cbff",15400:"#b2cbff",15600:"#b1caff",15800:"#b1caff",16000:"#b0caff",16200:"#afc9ff",16400:"#afc9ff",16600:"#afc9ff",16800:"#aec9ff",17000:"#aec8ff",17200:"#adc8ff",17400:"#adc8ff",17600:"#acc7ff",17800:"#acc7ff",18000:"#acc7ff",18200:"#abc7ff",18400:"#abc6ff",18600:"#aac6ff",18800:"#aac6ff",19000:"#aac6ff",19200:"#a9c6ff",19400:"#a9c5ff",19600:"#a9c5ff",19800:"#a9c5ff",20000:"#a8c5ff",20200:"#a8c5ff",20400:"#a8c4ff",20600:"#a7c4ff",20800:"#a7c4ff",21000:"#a7c4ff",21200:"#a7c4ff",21400:"#a6c3ff",21600:"#a6c3ff",21800:"#a6c3ff",22000:"#a6c3ff",22200:"#a5c3ff",22400:"#a5c3ff",22600:"#a5c3ff",22800:"#a5c2ff",23000:"#a4c2ff",23200:"#a4c2ff",23400:"#a4c2ff",23600:"#a4c2ff",23800:"#a4c2ff",24000:"#a3c2ff",24200:"#a3c1ff",24400:"#a3c1ff",24600:"#a3c1ff",24800:"#a3c1ff",25000:"#a3c1ff",25200:"#a2c1ff",25400:"#a2c1ff",25600:"#a2c1ff",25800:"#a2c1ff",26000:"#a2c0ff",26200:"#a2c0ff",26400:"#a1c0ff",26600:"#a1c0ff",26800:"#a1c0ff",27000:"#a1c0ff",27200:"#a1c0ff",27400:"#a1c0ff",27600:"#a1c0ff",27800:"#a0c0ff",28000:"#a0bfff",28200:"#a0bfff",28400:"#a0bfff",28600:"#a0bfff",28800:"#a0bfff",29000:"#a0bfff",29200:"#a0bfff",29400:"#9fbfff",29600:"#9fbfff",29800:"#9fbfff",temp:1e10,col:"#9fbfff"
}
const classes = {
  2400: "M",
  3700: "K",
  5200: "G",
  6000: "F",
  7500: "A",
  10000: "B",
  30000: "O",
}

// Conversions
const abs_mag_to_sol_lum = (M) => 
  Math.pow(100, -M/5)
  
const bv_to_temp = (i) => 
  4600 * (1/(0.92*i + 1.7) + 1/(0.92*i + 0.62))
  
const radius_lum_to_temp = (R, L) => 
  ( L*L_sun / ((4*PI*R*R*R_sun*R_sun) * STEFAN) ) ** (1/4)
  
const temp_to_col = (T) => from_interval(blackbody, T)

// Probability density function of stars' initial masses
const initial_mass_function = M => (
  in_range(0.08, M, 0.50) ? 0.035 * Math.pow(M, -1.3)
  : in_range (0.50, M, 1.00) ? 0.019 * Math.pow(M, -2.2)
  : in_range (1.00, M, 100) ? 0.019 * Math.pow(M, -2.7)
  : 0
)

// Zeta function of metallicity Z
const phases = {
  C_MS: { name: "Main sequence below 0.7 M", index: 0, },
  MS: { name: "Main sequence above 0.7 M", index: 1, },
  HG: { name: "Hertzsprung Gap", index: 2, },
  GB: { name: "First Giant Branch", index: 3, },
  CHeB: { name: "Core Helium Burning", index: 4, },
  EAGB: { name: "Early Asymptotic Giant Branch", index: 5, },
  TAPGB: { name: "Thermally Pulsating Asymptotic Giant Branch", index: 6, },
  He_MS: { name: "Naked Helium Star Main Sequence", index: 7, },
  He_HG: { name: "Naked Helium Star Hertzsprung Gap", index: 8, },
  He_GB: { name: "Naked Helium Star Giant Branch", index: 9, },
  He_WD: { name: "Helium White Dwarf", index: 10, },
  CO_WD: { name: "Carbon/Oxygen White Dwarf", index: 11, },
  ONe_WD: { name: "Oxygen/Neon White Dwarf", index: 12, },
  NS: { name: "Neutron Star", index: 13, },
  BH: { name: "Black Hole", index: 14, },
  R: { name: "massless remnant", index: 15, },
}

const regimes = {
  LM: { name: "Low mass", index: 0, },
  IM: { name: "Intermediate mass", index: 1, },
  HM: { name: "High mass", index: 2, },
}

const polynomial = x => coefficients => 
  coefficients.reduce((sum, coefficient, degree) => 
    sum + coefficient * (x**degree)
  , 0)

const rational = x => (...pairs) =>
  pairs.reduce((sum, [coefficient, exponent]) => 
    sum + coefficient * (x ** exponent)
  , 0)

const fit = x => (...numerator) => (...denominator) =>
  rational(x)(...numerator) / rational(x)(...denominator)

const from_coefficients = x => (...coefficients) =>
  coefficients.map(polynomial(x))

let min_bv = -0.5, max_bv = +3
let min_temp = bv_to_temp(min_bv), max_temp = bv_to_temp(max_bv)

let min_mag = +10, max_mag = -20
let min_sol_lum = abs_mag_to_sol_lum(min_mag), max_sol_lum = abs_mag_to_sol_lum(max_mag)

let min_mass = 0.1, max_mass = 10

const n_stars = 100

const display = true

const bubble_config = {
  count: 7,
  rmin: 5,
  rmax: 15,
  min: 0,
  max: 100
}

const stars = {}

const star_init = (id, M, Z) => {
  
  const $ = { 
    id, 
    M: { ZAMS: M }, // mass
    Mc: { }, // core mass
    
    X: 0.76 - 3*Z, // hydrogen abunance (T p.1)
    Y: 0.24 + 2*Z, // helium abundance (T p.1)
    Z: Z, // metallicity (T p.1)
    σ: log10(Z), // log metallicity (H Appendix)
    ζ: log10(Z/Z_sun), // relative log metallicity (H Appendix)
    ρ: log10(Z/Z_sun) + 1.0,
    
    L: { }, // luminosity
    R: { }, // radius
    T: { }, // temperature
    t: { }, // time
    τ: { }, // relative time
    _: { }, // misc
  }
  
  $.polynomial = polynomial($.ζ)
  $.from_coefficients = from_coefficients($.ζ)

  // (H1, H2, H3)
  // Constant stuff
  {
    // (H1)
    // the initial mass above which a hook appears in the main-sequence
    $.M.hook = 1.0185 + 0.16015*$.ζ + 0.0892*$.ζ*$.ζ

    // (H2)
    // the maximum initial mass for which He ignites degenerately in a helium flash
    $.M.HeF = 1.995 + 0.25*$.ζ + 0.087*$.ζ*$.ζ

    // (H3)
    // the maximum initial mass for which He ignites on the first giant branch
    $.M.FGB = 13.048 * ((Z/0.02)**0.06) / (1 + 0.0012*((0.02/Z)**1.27))

    // (H p.5)
    $.L_I_H = (low, intermediate, high) => (M < $.M.HeF) ? low
    : in_range($.M.HeF, M, $.M.FGB) ? intermediate
    : high

    $.L_IH = (low, other) => $.L_I_H(low, other, other)
    $.LI_H = (other, high) => $.L_I_H(other, other, high)

    // where the mass of the convective envelope MCE first exceeds a set fraction of the envelope mass ME
    $.ratio_CE_E = $.L_IH(2/5, 1/3)
  }
  check($.M.hook)
  check($.M.HeF)
  check($.M.FGB)
  check($.ratio_CE_E)
  
  // BEGIN COEFFICIENTS

  // (T p.2)
  
  const [ aα, aβ, aγ, aδ, aε, aζ, aη ] = $.from_coefficients(
    [ 0.3970417, -0.32913574, 0.34776688, 0.37470851, 0.09011915 ],
    [ 8.527626, -24.41225973, 56.43597107, 37.06152575, 5.4562406 ],
    [ 0.00025546, -0.00123461, -0.00023246, 0.00045519, 0.00016176 ],
    [ 5.432889, -8.62157806, 13.44202049, 14.51584135, 3.39793084 ],
    [ 5.563579, -10.32345224, 19.4432298, 18.97361347, 4.16903097 ],
    [ 0.7886606, -2.90870942, 6.54713531, 4.05606657, 0.53287322 ],
    [ 0.00586685, -0.01704237, 0.03872348, 0.02570041, 0.00383376 ]
  )
  
  const [ aθ, aι, aκ, aλ, aμ, aν, aξ, aο, aπ ] = $.from_coefficients(
    [ 1.715359, 0.62246212, -0.92557761, -1.16996966, -0.30631491 ], 
    [ 6.597788, -0.42450044, -12.13339427, -10.73509484, -2.51487077 ],
    [ 10.08855, -7.11727086, -31.67119479, -24.24848322, -5.33608972 ],
    [ 1.012495, 0.3269969, -0.00923418, -0.03876858, -0.0041275 ],
    [ 0.07490166, 0.02410413, 0.07233664, 0.03040467, 0.00197741 ],
    [ 0.01077422, 0, 0, 0, 0 ],
    [ 3.082234, 0.9447205, -2.15200882, -2.49219496, -0.63848738 ],
    [ 17.84778, -7.4534569, -48.96066856, -40.05386135, -9.09331816 ],
    [ 0.00022582, -0.00186899, 0.00388783, 0.00142402, -0.00007671 ]
  ) 
  
    
  // (H p.24)
  
  const [ a1, a2, a3, a4, a5 ] = $.from_coefficients(
    [1.593890e+3, 2.053038e+3, 1.231226e+3, 2.327785e+2],
    [2.706708e+3, 1.483131e+3, 5.772723e+2, 7.411230e+1],
    [1.466143e+2, -1.048442e+2, -6.795374e+1, -1.391127e+1],
    [4.141960e-2, 4.564888e-2, 2.958542e-2, 5.571483e-3],
    [3.426349e-1]
  )

  const [ a6, a7, a8, a9, a10 ] = $.from_coefficients(
    [1.949814e+1, 1.758178e+0, -6.008212e+0, -4.470533e+0],
    [4.903830e+0],
    [5.212154e-2, 3.166411e-2, -2.750074e-3, -2.271549e-3],
    [1.312179e+0, -3.294936e-1, 9.231860e-2, 2.610989e-2],
    [8.073972e-1]
  )
  
  const [ _a11, _a12, a13, a14, a15, a16 ] = $.from_coefficients(
    [1.031538e+0, -2.434480e-1, 7.732821e+0, 6.460705e+0, 1.374484e+0],
    [1.043715e+0, -1.577474e+0, -5.168234e+0, -5.596506e+0, -1.299394e+0],
    [7.859573e+2, -8.542048e+0, -2.642511e+1, -9.585707e+0],
    [3.858911e+3, 2.459681e+3, -7.630093e+1, -3.486057e+2, -4.861703e+1],
    [2.888720e+2, 2.952979e+2, 1.850341e+2, 3.797254e+1],
    [7.196580e0, 5.613746e-1, 3.805871e-1, 8.398728e-2],
  )
  const a11 = _a11 * a14
  const a12 = _a12 * a14

  const [ _a18, _a19, a20, a21, a22, a23, a24, a25, a26 ] = $.from_coefficients(
    [2.187715e-1, -2.154437e+0, -3.768678e+0, -1.975518e+0, -3.021475e-1],
    [1.466440e+0, 1.839725e+0, 6.442199e+0, 4.023635e+0, 6.957529e-1],
    [2.652091e+1, 8.178458e+1, 1.156058e+2, 7.633811e+1, 1.950698e+1],
    [1.472103e+0, -2.947609e+0, -3.312828e+0, -9.945065e-1],
    [3.071048e+0, -5.679941e+0, -9.745523e+0, -3.594543e+0],
    [2.617890e+0, 1.019135e+0, -3.292551e-2, -7.445123e-2],
    [1.075567e-2, 1.773287e-2, 9.610479e-3, 1.732469e-3],
    [1.476246e+0, 1.899331e+0, 1.195010e+0, 3.035051e-1],
    [5.502535e+0, -6.601663e-2, 9.968707e-2, 3.599801e-2],
  )
  const a17 = exp10(max(0.097 - 0.1072*($.σ + 3), max(0.097, min(0.1461, 0.1461 + 0.1237*($.σ + 2)))))
  const a18 = _a18 * a20
  const a19 = _a19 * a20

// (H p.25)

  const [ a27, a28, _a29, a30, a31, a32 ] = $.from_coefficients(
    [9.511033e+1, 6.819618e+1, -1.045625e+1, -1.474939e+1],
    [3.113458e+1, 1.012033e+1, -4.650511e+0, -2.463185e+0],
    [1.413057e+0, 4.578814e-1, -6.850581e-2, -5.588658e-2],
    [3.910862e+1, 5.196646e+1, 2.264970e+1, 2.873680e+0],
    [4.597479e+0, -2.855179e-1, 2.709724e-1],
    [6.682518e+0, 2.827718e-1, -7.294429e-2],
  )
  const a29 = _a29 ** a32
  
  const [ a34, a35, a36, a37 ] = $.from_coefficients(
    [1.910302e-1, 1.158624e-1, 3.348990e-2, 2.599706e-3],
    [3.931056e-1, 7.277637e-2, -1.366593e-1, -4.508946e-2],
    [3.267776e-1, 1.204424e-1, 9.988332e-2, 2.455361e-2],
    [5.990212e-1, 5.570264e-2, 6.207626e-2, 1.777283e-2],
  )
  const _a33 = min(1.4, 1.5135 + 0.3769 * $.ζ)
  const a33 = max(0.6355 - 0.4192 * $.ζ, max(1.25, _a33))

  const [ a38, a39, a40, a41, _a42, a43, _a44 ] = $.from_coefficients(
    [7.330122e-1, 5.192827e-1, 2.316416e-1, 8.346941e-3],
    [1.172768e+0, -1.209262e-1, -1.193023e-1, -2.859837e-2],
    [3.982622e-1, -2.296279e-1, -2.262539e-1, -5.219837e-2],
    [3.571038e+0, -2.223625e-2, -2.611794e-2, -6.359648e-3],
    [1.9848e+0, 1.1386e+0, 3.5640e-1],
    [6.300e-2, 4.810e-2, 9.840e-3],
    [1.200e+0, 2.450e+0],
  )
  const a42 = min(1.25, max(1.1, _a42))
  const a44 = min(1.3, max(0.45, _a44))
  
  const [ a45, a46, a47, a48, _a49, _a50, _a51, _a52, _a53 ] = $.from_coefficients(
    [2.321400e-1, 1.828075e-3, -2.232007e-2, -3.378734e-3],
    [1.163659e-2, 3.427682e-3, 1.421393e-3, -3.710666e-3],
    [1.048020e-2, -1.231921e-2, -1.686860e-2, -4.234354e-3],
    [1.555590e+0, -3.223927e-1, -5.197429e-1, -1.066441e-1],
    [9.7700e-2, -2.3100e-1, -7.5300e-2],
    [2.4000e-1, 1.8000e-1, 5.9500e-1],
    [3.3000e-1, 1.3200e-1, 2.1800e-1],
    [1.1064e+0, 4.1500e-1, 1.8000e-1],
    [1.1900e+0, 3.7700e-1, 1.7600e-1],
  )
  const a49 = max(_a49, 0.145)
  const a50 = min(_a50, 0.306 + 0.053 * $.ζ)
  const a51 = min(_a51, 0.3625 + 0.062 * $.ζ)
  const a52 = (Z > 0.01) ? clamp(0.9, _a52, 1.0) : max(_a52, 0.9)
  const a53 = (Z > 0.01) ? clamp(1.0, _a53, 1.1) : max(_a53, 1.0)

  // (H p.26)
  
  const [ a54, a55, a56, _a57 ] = $.from_coefficients(
    [3.855707e-1, -6.104166e-1, 5.676742e+0, 1.060894e+1, 5.284014e+0],
    [3.579064e-1, -6.442936e-1, 5.494644e+0, 1.054952e+1, 5.280991e+0],
    [9.587587e-1, 8.777464e-1, 2.017321e-1],
    [1.5135e+0, 3.7690e-1]
  )
  const a57 = max(0.6355 - 0.4192*$.ζ, clamp(1.25, _a57, 1.4))

  const [ a58, a59, a60, a61, _a62, _a63, __a64, a65, __a66, a67, __a68 ] = $.from_coefficients(
    [4.907546e-1, -1.683928e-1, -3.108742e-1, -7.202918e-2],
    [4.537070e+0, -4.465455e+0, -1.612690e+0, -1.623246e+0],
    [1.796220e+0, 2.814020e-1, 1.423325e+0, 3.421036e-1],
    [2.256216e+0, 3.773400e-1, 1.537867e+0, 4.396373e-1],
    [8.4300e-2, -4.7500e-2, -3.5200e-2],
    [7.3600e-2, 7.4900e-2, 4.4260e-2],
    [1.3600e-1, 3.5200e-2],
    [1.564231e-3, 1.653042e-3, -4.439786e-3, -4.951011e-3, -1.216530e-3],
    [1.4770e+0, 2.9600e-1],
    [5.210157e+0, -4.143695e+0, -2.120870e+0],
    [1.1160e+0, 1.6600e-1],
  )
  const a62 = max(0.065, _a62)
  const a63 = (Z < 0.004) ? min(0.055, _a63) : _a63
  const _a64 = clamp(0.091, __a64, 0.121)
  const _a66 = max(__a66, min(1.6, 0.308 - 1.046 * $.ζ))
  const a66 = clamp(0.8, _a66, 0.8 - 2.0*$.ζ)
  const _a68 = max(0.9, min(__a68, 1.0))
  const a68 = min(_a68, a66)
  
  const [ a69, a70, a71, _a72, a73, _a74 ] = $.from_coefficients(
    [1.071489e+0, -1.164852e-1, -8.623831e-2, -1.582349e-2],
    [7.108492e-1, 7.935927e-1, 3.926983e-1, 3.622146e-2],
    [3.478514e+0, -2.585474e-2, -1.512955e-2, -2.833691e-3],
    [9.132108e-1, -1.653695e-1, 3.636784e-2],
    [3.969331e-3, 4.539076e-3, 1.720906e-3, 1.897857e-4],
    [1.600e+0, 7.640e-1, 3.322e-1]
  )
  const a72 = (Z>0.01) ? max(_a72, 0.95) : a72
  const a74 = clamp(1.4, _a74, 1.6)
    
  // (H p.27)
  
  const [ _a75, _a76, _a77, _a78, _a79, _a80, _a81 ] = $.from_coefficients(
    [8.109e-1, -6.282e-1],
    [1.192334e-2, 1.083057e-2, 1.230969e+0, 1.551656e+0],
    [-1.668868e-1, 5.818123e-1, -1.105027e+1, -1.668070e+1],
    [7.615495e-1, 1.068243e-1, -2.011333e-1, -9.371415e-2],
    [9.409838e+0, 1.522928e+0],
    [-2.7110e-1, -5.7560e-1, -8.3800e-2],
    [2.4930e+0, 1.1475e+0]
  )
  const a75 = max(clamp(1.0, _a75, 0.6355 - 0.4192*$.ζ), 1.27)
  const a76 = max(_a76, -0.1015564 - 0.2161264*$.ζ - 0.05182516*$.ζ*$.ζ)
  const a77 = clamp(-0.3868776 - 0.5457078*$.ζ - 0.146347*$.ζ*$.ζ, _a77, 0.0)
  const a78 = clamp(0.0, _a78, 7.454 + 9.046*$.ζ)
  const a79 = clamp(2.0, -13.3 - 18.6*$.ζ, _a79)
  const a80 = max(0.0585542, _a80)
  const a81 = clamp(0.4, _a81, 1.5)

  const [ _b1, _b4, b5, _b6, b7 ] = $.from_coefficients(
    [3.9700e-1, 2.8826e-1, 5.2930e-1],
    [9.960283e-1, 8.164393e-1, 2.383830e+0, 2.223436e+0, 8.638115e-1],
    [2.561062e-1, 7.072646e-2, -5.444596e-2, -5.798167e-2, -1.349129e-2],
    [1.157338e+0, 1.467883e+0, 4.299661e+0, 3.130500e+0, 6.992080e-1],
    [4.022765e-1, 3.050010e-1, 9.962137e-1, 7.914079e-1, 1.728098e-1]
  )
  const b1 = min(0.54, _b1)
  const b2 = clamp(-0.04167 + 55.67*Z, exp10(-4.6739 - 0.9394*$.σ), 0.4771 - 9329.21*(Z**2.94))
  const _b3 = exp10(max(-0.1451, -2.2794 - 1.5175*$.σ - 0.254*$.σ*$.σ))
  const b3 = (Z > 0.004) ? max(_b3, 0.7307 + 14265.1 * (Z**3.395)) : _b3
  const b4 = _b4 + 0.1231572 * ($.ζ**5)
  const b6 = _b6 + 0.01640687 * ($.ζ**5)
  
  const b8 = NaN

  const [ b9, b10, _b11, b12, _b13 ] = $.from_coefficients(
    [2.751631e+3, 3.557098e+2],
    [-3.820831e-2, 5.872664e-2],
    [1.071738e+2, -8.970339e+1, -3.949739e+1],
    [7.348793e+2, -1.531020e+2, -3.793700e+1],
    [9.219293e+0, -2.005865e+0, -5.561309]
  )
  const b11 = _b11*_b11
  const b13 = _b13*_b13
  
  const [ _b14, b15, _b16 ] = $.from_coefficients(
    [2.917412e+0, 1.575290e+0, 5.751814e-1],
    [3.629118e+0, -9.112722e-1, 1.042291e+0],
    [4.916389e+0, 2.862149e+0, 7.84485]
  )
  const b14 = _b14**b15
  const b16 = _b16**b15
  const b17 = ($.ζ > -1.0) ? (1.0 - 0.3880523 * (($.ζ + 1.0)**2.862149)) : 1.0
  
  // (H p.28)
  
  const [ b18, b19, b20, b21, b22, b23 ] = $.from_coefficients(
    [5.496045e+1, -1.289968e+1, 6.385758e+0],
    [1.832694e+0, -5.766608e-2, 5.696128e-2],
    [1.211104e+2],
    [2.214088e+2, 2.187113e+2, 1.170177e+1, -2.635340e+1],
    [2.063983e+0, 7.363827e-1, 2.654323e-1, -6.140719e-2],
    [2.003160e+0, 9.388871e-1, 9.656450e-1],
  )

  const [ _b24, b25, _b27, b28 ] = $.from_coefficients(
    [1.609901e+1, 7.391573e+0, 2.277010e+1, 8.334227e+0],
    [1.747500e-1, 6.271202e-2, -2.324229e-2, -1.844559e-2],
    [2.752869e+0, 2.729201e-2, 4.996927e-1, 2.496551e-1],
    [3.518506e+0, 1.112440e+0, -4.556216e-1, -2.179426e-1],
  )
  const b24 = _b24**b28
  const b26 = 5.0 - 0.09138012 * (Z**-0.3671407)
  const b27 = _b27**(2*b28)

  const [ b29, b30, _b31, b32, b33, _b34 ] = $.from_coefficients(
    [1.626062e+2, -1.168838e+1, -5.498343e+0],
    [3.336833e-1, -1.458043e-1, -2.011751e-2],
    [7.425137e+1, 1.790236e+1, 3.033910e+1, 1.018259e+1],
    [9.268325e+2, -9.739859e+1, -7.702152e+1, -3.158268e+1],
    [2.474401e+0, 3.892972e-1],
    [1.127018e+1, 1.622158e+0, -1.443664e+0, -9.474699e-1],
  )
  const b31 = _b31 ** b33
  const b34 = _b34 ** b33

  const [ _b36, _b37, _b38 ] = $.from_coefficients(
    [1.445216e-1, -6.180219e-2, 3.093878e-2, 1.567090e-2],
    [1.304129e+0, 1.395919e-1, 4.142455e-3, -9.732503e-3],
    [5.114149e-1, -1.160850e-2]
  )
  const b36 = _b36 ** 4
  const b37 = 4.0 * _b37
  const b38 = _b38 ** 4
  
  const [ b39, _b40, _b41, b42, b43, _b44 ] = $.from_coefficients(
    [1.314955e+2, 2.009258e+1, -5.143082e-1, -1.379140e+0],
    [1.823973e+1, -3.074559e+0, -4.307878e+0],
    [2.327037e+0, 2.403445e+0, 1.208407e+0, 2.087263e-1],
    [1.997378e+0, -8.126205e-1],
    [1.079113e-1, 1.762409e-2, 1.096601e-2, 3.058818e-3],
    [2.327409e+0, 6.901582e-1, -2.158431e-1, -1.084117e-1,]
  )
  const b40 = max(_b40, 1.0)
  const b41 = _b41 ** b42
  const b44 = _b44 ** 5

  // (H p.29)
  
  const [_b46, b48, b49] = (
    [2.214315e+0, -1.975747e+0],
    [5.072525e+0, 1.146189e+1, 6.961724e+0, 1.316965e+0],
    [5.139740e+0]
  )
  const b45 = ($.ρ < 0.0) ? 1.0 : 1.0 - ( 2.47162*$.ρ - 5.401682*($.ρ**2) + 3.2473613*($.ρ**3) )
  const b46 = -1.0 * _b46 * log10($.M.HeF / $.M.FGB)
  const b47 = 1.127733*$.ρ + 0.2344416*($.ρ**2) - 0.3793726*($.ρ**3)
  
  const [ _b51, b52, _b53, b54, _b55, _b56, _b57 ] = $.from_coefficients(
    [1.125124e+0, 1.306486e+0, 3.622359e+0, 2.601976e+0, 3.031270e-1],
    [3.349489e-1, 4.531269e-3, 1.131793e-1, 2.300156e-1, 7.632745e-2],
    [1.467794e+0, 2.798142e+0, 9.455580e+0, 8.963904e+0, 3.339719e+0],
    [4.658512e-1, 2.597451e-1, 9.048179e-1, 7.394505e-1, 1.607092e-1],
    [1.0422e+0, 1.3156e-1, 4.5000e-2],
    [1.110866e+0, 9.623856e-1, 2.735487e+0, 2.445602e+0, 8.826352e-1],
    [-1.584333e-1, -1.728865e-1, -4.461431e-1, -3.925259e-1, -1.276203e-1]
  )
  const b51 = _b51 - 0.134379 * ($.ζ ** 5)
  const b53 = _b53 - 0.4426929 * ($.ζ ** 5)
  const b55 = min(_b55, 0.99164 - 743.123*(Z**2.83))
  const b56 = _b56 + 0.1140142 * ($.ζ ** 5)
  const b57 = _b57 - 0.01308728 * ($.ζ ** 5)
    
  // END COEFFICIENTS
    
  $.fit = fit($.M.ZAMS)
  $.lerp = lerp($.M.ZAMS)
  
  // Zero-age main sequence mass and radius
  
  // (T1)
  {
    $.L.ZAMS = $.fit
    ([aα, 5.5], [aβ, 11])
    ([aγ, 0], [1, 3], [aδ, 5], [aε, 7], [aζ, 8], [aη, 9.5])
  }
  
  // (T2)
  {
    $.R.ZAMS = $.fit
    ([aθ, 2.5], [aι, 6.5], [aκ, 11], [aλ, 19], [aμ, 19.5])
    ([aν, 0], [aξ, 2], [aο, 8.5], [1, 18.5], [aπ, 19.5])
  }
  check($.R.ZAMS)
  
  check($.L.ZAMS)
  
  // [5.1] Main-sequence and Hertzsprung gap
  
  // (H4)
  {
    $.t.BGB = $.fit
    ([a1, 0], [a2, 4], [a3, 5.5], [1, 7])
    ([a4, 2], [a5, 7])
  }
  check($.t.BGB)
  
  // (H5, H6, H7)
  {
    
    // (H7)
    const µ = max(0.5, 1 - 0.01 * max(a6 / (M**a7), a8 + a9/(M**a10)))
    
    $.t.hook = µ * $.t.BGB
    
    // (H6)
    const x = max(0.95, min(0.95 - 0.03*($.ζ + 0.30103), 0.99))
    
    // (H5)
    $.t.MS = max($.t.hook, x * $.t.BGB)
  }
  check($.t.hook)
  check($.t.MS)
  
  // (H8)
  {
    $.L.TMS = $.fit
    ([a11, 3], [a12, 4], [a13, a16 + 1.8])
    ([a14, 0], [a15, 5], [1, a16])
  }
  check($.L.TMS)
  
  // (H9)
  {
    const c1 = -8.672073e-2
    const M_star = a17 + 0.1

    $.R.TMS = $.lerp(a17, M_star) (
      fit (max(M, a17)) ([a18, 0], [a19, a21]) ([a20, 0], [1, a22]),
      fit (min(M_star, M)) ([c1, 3], [a23, a26], [a24, a26+1.5]) ([a25, 0], [1, 5])
    )

    if(M < 0.5) $.R.TMS = max($.R.TMS, 1.5*$.R.ZAMS)
  }
  check($.R.TMS)
  
  // (H10)
  {
    const c2 = 9.301992
    const c3 = 4.637345
    
    $.L.BGB_ = M => fit(M)
      ([a27, a31], [a28, c2])
      ([a29, 0], [a30, c3], [1, a32])
    $.L.BGB = $.L.BGB_(M)
  }
  check($.L.BGB)
  
  // (H11, H12, H13, H14, H15, H24)
  {
    // (H11)
    $.τ.MS_ = t => t / $.t.MS

    // (H12)
    $.L.MS_ = (τ, τ1, τ2) => $.L.ZAMS * exp10(
      $.L.α*(τ) 
      + $.L.β*(τ**$.η)
      + (log10($.L.TMS/$.L.ZAMS) - $.L.α - $.L.β)*(τ*τ)
      - $.L.Δ*(τ1*τ1 - τ2*τ2)
    )

    // (H13, H24)
    $.R.MS_ = (τ, τ1, τ2) => max(
      $.R.ZAMS * exp10(
        $.R.α*(τ) 
        + $.R.β*(τ**10)
        + $.R.γ*(τ**40)
        + (log10($.R.TMS/$.R.ZAMS) - $.R.α - $.R.β - $.R.γ)*(τ*τ*τ)
        - $.R.Δ*(τ1*τ1*τ1 - τ2*τ2*τ2)
      ), 
      0.0258 * ((1.0 + $.X)**(5/3)) * (M**(-1/3))
    )
    
    const ε = 0.01

    // (H14)
    $.τ.MS_1_ = t => min(1.0, t/$.t.hook)

    // (H15)
    $.τ.MS_2_ = t => clamp(0.0, (t - (1.0 - ε)*$.t.hook)/(ε * $.t.hook), 1.0)
  }
  
  // (H16)
  {
    const L_ = M => min(a34 / (M**a35), a36 / (M**a37))
    
    $.L.Δ = ( M < $.M.hook ) ? 0
    : in_range($.M.hook, M, a33) ? L_(a33)*(((M - $.M.hook)/(a33 - $.M.hook))**0.4)
    : ( M > a33 ) ? L_(M)
    : 0
  }
  check($.L.Δ)
  
  // (H17)
  {
    
    const B = M => fit(M)([a38, 0], [a39, 3.5])([a40, 3], [1, a41]) - 1

    $.R.Δ = ( M < $.M.hook ) ? 0
    : in_range($.M.hook, M, a42) ? a43 * sqrt((M - $.M.hook)/(a42 - $.M.hook))
    : in_range(a42, M, 2.0) ? a43 + (B(2.0) - a43)*(((M-a42)/(2-a42))**a44)
    : ( M > 2.0 ) ? B(M)
    : 0.0
  }
  check($.R.Δ)

   // (H18)
  $.η = (Z > 0.0009 || M < 10) ? 10 : 20
  check($.η)
  
  // (H19)
  {
    
    const B = M => fit(M)([a45, 0], [a46, a48])([1, 0.4], [a47, 1.9])
    
    $.L.α = ( M < 0.5) ? a49
    : in_range(0.5, M, 0.7) ? a49 + 5.0*(0.3 - a49)*(M - 0.5)
    : in_range(0.7, M, a52) ? 0.3 + (a50 - 0.3)*(M - 0.7)/(a52 - 0.7)
    : in_range(a52, M, a53) ? a50 + (a51 - a50)*(M - a52)/(a53 - a52)
    : in_range(a53, M, 2.0) ? a51 + (B(2.0) - a51)*(M - a53)/(2.0 - a53)
    : ( M > 2.0 ) ? B(M)
    : 0.0
  }
  check($.L.α)
  
  // (H20)
  {
    const B = M => max(0.0, a54 - a55*(M**a56))
    
    $.L.β = (M > a57 && B(M) > 0.0) ? max(0.0, B(a57) - 10.0*B(a57)*(M-a57))
    : B(M)
  }
  check($.L.β)
  
  // (H21)
  {        
    const B = M => fit(M)([a58, a60])([a59, a61])
    const a64 = (_a68 > a66) ? B(a66) : _a64
    
    $.R.α = in_range(a66, M, a67) ? B(M)
    : (M < 0.5) ? a62
    : in_range(0.5, M, 0.65) ? a62 + (a63-a62)*(M-0.5) / 0.15
    : in_range(0.65, M, a68) ? a63 + (a64-a63)*(M-0.65) / (a68 - 0.65)
    : in_range(a68, M, a66) ? a64 + (B(a66) - a64)*(M - a68) / (a66 - a68)
    : (M > a67) ? B(a67) + a65*(M - a67)
    : 0.0
  }
  check($.R.α)
  
  // (H22)
  {
    
    const B = M => fit(M)([a69, 3.5])([a70, 0], [1, a71])
    $.R.β = (M < 1.0) ? 1.06
    : in_range(1.0, M, a74) ? 1.06 + (a72 - 1.06)*(M - 1.0)/(a74 - 1.06)
    : in_range(a74, M, 2.0) ? a74 + (B(2.0) - a72)*(M - a74)/(2.0 - a74)
    : (M > 16.0) ? B(16.0) + a73*(M - 16.0)
    : 0.0
  }
  check($.R.β)
  
  // (H23)
  {
    const B = M => a76 + a77*((M-a78)**a79)
    const C = (a75 < 1.0) ? C = B(1.0) : a80
    $.R.γ = (M > a75 + 0.1) ? 0.0
    : (M <= 1.0) ? B(M)
    : in_range(1.0, M, a75) ? B(1.0) + (a80 - B(1.0))*(((M-1.0)/(a75-1.0))**a81)
    : in_range(a75, M, a75+1.0) ? C - 10.0*(M-a75)*C
    : 0.0
  }
  check($.R.γ)

   // (H49, H50)
  {
    
    const B = (M) => fit(M)([b11, 0], [b12, 3.8])([b13, 0], [1, 2])
    const α1 = (b9*($.M.HeF**b10) - B($.M.HeF)) / B($.M.HeF)
    
    // (H49)
    $.L.HeI_ = M => $.L_IH(
      (b9 * (M**b10)) / (1 + α1*exp(15*(M - $.M.HeF))),
      B(M)
    )
    $.L.HeI = $.L.HeI_(M)
    
    // (H50b)
    const µ = log10(M/12.0) / log10($.M.FGB/12.0)

    // (H50a)
    $.R.HeI_ = Mc => (M < $.M.FGB) ? $.R.GB_($.L.HeI)
    : (M > max($.M.FGB, 12.0)) ? $.R.mHe_(Mc)
    : in_range($.M.FGB, M, 12.0) ? $.R.mHe * (($.R.GB_($.L.HeI) / $.R.mHe_(Mc)) ** µ)
    : 0.0

    // (H p.6)
    $.L.EHG = (M < $.M.FGB) ? $.L.BGB : $.L.HeI
    $.R.EHG_ = Mc => (M < $.M.FGB) ? $.R.BGB : $.R.HeI_(Mc)
  }
  check($.L.HeI)
  check($.L.EHG)

  // (H66)
  {
    $.Mc.BAGB = (b36 * (M**b37) + b38) ** (1/4)
  }
  check($.Mc.BAGB)


  // (H34, H37, H38, H39, H40, H41, H42, H43)
  {    
    // (H p.10)
    const F = $.lerp($.M.HeF, 2.5)
    const p = F(6, 5)
    const q = F(3, 2)
    const B = max(3e+4, 500 + 1.75e+4 * (M**0.6))
    const D0 = 5.37 * 0.135 * $.ζ
    const D = exp10(F(
      D0, max(-1.0, max(0.975*D0 - 0.18*M, 0.5*D0 - 0.06*M))
    ))
    const A_H = exp10(
      max(-4.8, min(-5.7 + 0.8*M, -4.1 + 0.14*M))
    )
    
    // (H31)
    $.Mc.L_ = Mc => D * (Mc**p)
    $.L.Mc_ = L => (L/D) ** (1/p)
    
    // (H34)
    const Mc_ = (p, D, t_inf) => t =>
      ( (p-1) * A_H * D * (t_inf - t) ) ** ( 1 / (1-p) )

    // (H38)
    const Mx = (B/D)**(1/(p - q))
    
    // (H37)
    // L at crossover point
    const Lx = min(
      B * (Mx**q),
      D * (Mx**p)
    )
    
    // (H40)
    const t_inf_1 = $.t.BGB 
      + (1/(A_H * D * (p-1)))
      * ( (D/$.L.BGB)**((p-1)/p) )

    // (H41)
    // t at crossover point
    const tx = t_inf_1
      - (t_inf_1 - $.t.BGB) 
      * ( ($.L.BGB/Lx) ** ((p-1)/p) )

    // (H42)
    const t_inf_2 = tx
      + (1/(A_H * B * (q-1))) 
      * ( (B/Lx) ** ((q-1)/q) )

    // (H37)
    $.L.GB_ = t => min(
      B * (Mc_(p, B, t_inf_1)(t) ** q), 
      D * (Mc_(q, D, t_inf_2)(t) ** p)
    )
    
    // (H39)
    $.Mc.GB_1_ = t => (
      (t < tx) ? Mc_(p, D, t_inf_2) : Mc_(q, B, t_inf_2)
    )(t)
  
    // (H43)  
    const t1 = t_inf_1 
      - (1/(A_H * D * (p-1)))
      * ((D/$.L.HeI)**((p-1)/p))
    const t2 = t_inf_2
      - (1/(A_H * D * (q-1)))
      * ((D/$.L.HeI)**((q-1)/q))
    $.t.HeI = ($.L.HeI < Lx) ? t1 : t2
  }
  check($.t.HeI)
  
  // (H44)
  {
    const c1 = 9.20925e-5
    const c2 = 5.402216
    const C_BCB = ($.Mc.L_($.L.BGB_($.M.HeF)) ** 4) - c1*($.M.HeF ** c2)

    // (H44)
    $.Mc.BGB = min(
      0.95 * $.Mc.BAGB, 
      ( C_BCB + c1*(M**c2) ) ** (1/4)
    )

    const C_HeI = ($.Mc.L_($.L.HeI_($.M.HeF)) ** 4) - c1*($.M.HeF ** c2)

    // (H p.13)
    $.Mc.HeI = $.L_IH(
      $.Mc.L_($.L.HeI),
      ( C_HeI + c1*(M**c2) ) ** (1/4)
    )
  }
  check($.Mc.HeI)
  
  // (H25, H26, H27, H28, H29, H30) 
  {
    // (H25)
    $.τ.HG_ = t => (t - $.t.MS) / ($.t.BGB - $.t.MS)
    
    // (H26)
    $.L.HG_ = τ => $.L.TMS * (($.L.EHG / $.L.TMS) ** τ)

    // (H27)
    $.R.HG_ = (Mc, τ) => $.R.TMS * (($.R.EHG_(Mc) / $.R.TMS) ** τ)      

    $.Mc.MS = 0.0
    
    // (H28)
    $.Mc.EHG =  $.L_I_H(
      $.Mc.BGB, // $.Mc.GB
      $.Mc.BGB,
      $.Mc.HeI
    )
    
    // (H29)
    const ρ = (1.586 + (M**5.25)) / (2.434 + 1.02*(M**5.25))
    $.Mc.TMS = ρ * $.Mc.EHG

    // (H30)
    $.Mc.HG_ = τ => ((1-τ)*$._.ρ + τ) * $.Mc.EHG
  }
  check($.Mc.EHG)
  check($.Mc.TMS)
  
  // [5.2] First giant branch
  
  
  // (H45)
  {
    // (H p.11)
    $.τ.GB_ = t => (t - $.t.BGB) / ($.t.HeI - $.t.BGB)
    
    // (H45)
    $.Mc.GB_ = (t, τ) => (M > $.M.HeF) ? $.Mc.BGB + ($.Mc.HeI - $.Mc.BGB) * τ
    : $.Mc.GB_1_(t)
  }
  
  // (H46)
  {
        
    // (H46)
    $.R.GB__ = (A) => (L) => A * (L**b1 + b2*(L**b3))
    const A = min(b4 * (M**-b5), b6 * (M**-b7))
    $.R.GB_ = (L) => $.R.GB__(A)(L)
  }
  
  // [5.3] Core helium burning
 
  
  // (H51)
  { 
    const c = b17/($.M.FGB**0.1) + (b16*b17 - b14)/($.M.FGB**(b15 + 0.1))
    $.L.min_He_ = M => $.L.HeI * fit(M)
      ([b14, 0], [c, b15+0.1])
      ([b16, 0], [1, b15])
    $.L.min_He = $.L.min_He_(M)
  }
  check($.L.min_He)
  
  // (H77, H78)
  {
    // (H77)
    $.L.ZHe_ = M => $.fit
      ([15262, 10.25])
      ([1, 9], [29.54, 7.5], [31.18, 6], [0.0469, 0])
    $.L.ZHe = $.L.ZHe_(M)
    
    // (H78)
    $.R.ZHe_ = M => $.fit
      ([0.2391, 4.6])
      ([1, 4], [0.162, 3], [0.0065, 0])
    $.R.ZHe = $.R.ZHe_(M)
  }
  check($.L.ZHe)
  check($.R.ZHe)
  
  // (H79)
  {
    $.t.HeMS_ = M => fit(M)
      ([0.4129, 0], [18.81, 4], [1.853, 6])
      ([1, 6.5])
    $.t.HeMS = $.t.HeMS_(M)
  }
  
  // (H74)
  {
    
    const M1 = $.M.HeF - 0.2
    const M2 = $.M.HeF
    const A1_ = M => b56 + b57*M
    const A2_ = M => min(b51 * (M**-b52), b53 * (M**-b54))
    $.R.AGB_ = L => $.lerp(M1, M2)( 
      $.R.GB__( A1_(max(M1, M)) )(L), 
      $.R.GB__( A2_(min(M, M2)) )(L)
    )
  }
  
  // (H52, H53, H54, H55)
  {
    const µ_ = Mc => (M - Mc)/($.M.HeF - Mc)
    
    // (H53)
    const α2_ = Mc => 
      (b18 + $.L.ZHe_(Mc) 
      - $.L.min_He_(M)) 
      / ($.L.min_He_($.M.HeF) - $.L.ZHe_(Mc))
    
    $.L.ZAHB__ = M => Mc => $.L.ZHe_(Mc) 
      + ((1 + b20) / (1 + b20*(µ_(Mc)**1.6479)))
      * (b18 * (µ_(Mc)**b19)) / (1 + α2_(M) * exp(15 * (M - $.M.HeF)))
    $.L.ZAHB_ = $.L.ZAHB__(M)
    
    // (H54)
    const f_ = Mc => ( (1.0 + b21) * (µ_(Mc) ** b22) ) / ( 1.0 + b21 * (µ_(Mc) ** b23) )
    $.R.ZAHB_ = Mc => mix($.R.GB_($.L.ZAHB), $.R.Zhe_(Mc))(f_(Mc))
    
    const R_ = (M) => fit(M)
      ([b24, 1], [b25**b26, b26+b28])
      ([b27, 0], [1, b28])
      
    const R1 = R_(M)
    const R2_ = Mc => $.R.GB_($.L.ZAHB_(Mc))
      *((R_($.M.HeF) / $.R.GB_($.L.ZAHB__($.M.HeF)(Mc))) ** $._.µ)

    // (H55)
    $.R.mHe_ = Mc => (M > $.M.HeF) ? R1 : R2_(Mc)
    
    
    const L_ = M => fit(M)
      ([b31, 0], [b32, b33+1.8])
      ([b34, 0], [1, b33])
      
    const α3 = ( b29 * ($.M.HeF**b30) - L_($.M.HeF) ) / L_($.M.HeF)
    
    // (H56)
    $.L.BAGB = (M > $.M.HeF) ? L_(M)
    : (b29 * (M**b30)) / (1 + α3 * exp(15 * M - $.M.HeF))
    
    $.R.BAGB = $.R.AGB_($.L.BAGB)
    
    const t_ = M => $.tBGB * $.fit
      ([b41, b42], [b43, 5])
      ([b44, 0], [1, 5])
      
    const α4 = (t_($.M.HeF) - b39)/b39
      
    // (H57)
    $.t.He_ = Mc => $.L_IH(
      (b39 + ($.t.HeMS_(Mc) - b39) * ((1 - µ_(Mc))**b40))
      * (1 + α4*exp(15 * (M - $.M.HeF))),
      t_(M)
    )
  }
  check($.L.BAGB)
  check($.R.BAGB)
  
  // (H58, H59, H60)
  {
    $.τ.CHeB_ = t => (t - $.t.HeI) / $.t.He
   
    // (H58c)
    const α_bl =
      (1 - b45*(($.M.HeF/$.M.FGB)**0.414)) 
      * (log10($.M.HeF/$.M.FGB)**-b46)
    
    // (H58b)
    const f_bl_ = M => 
      (M**b48) 
      * ((1 - $.R.mHe_(M)/$.R.AGB_($.L.HeI)) ** b49)
    const f_bl = f_bl_(M)

    // (H58a)
    const τ_bl = $.L_I_H(
      1.0,
      b45*((M/$.M.FGB)**0.414) + α_bl*(log10(M/$.M.FGB)**b46),
      (1-b47) * f_bl_(M) / f_bl_($.M.FGB)
    )
    
    // (H p.12)
    const τx = $.L_I_H(0, 1 - τ_bl, 0)
    
    // (H59)
    const Lx_ = Mc => $.L_I_H(
      $.L.ZAHB_(Mc),
      $.L.min_He,
      $.L.HeI
    )

    // (H60)
    const Rx_ = Mc => $.L_I_H(
      $.R.ZAHB_(Mc),
      $.R.GB_($.L.min_He),
      $.R.HeI_(Mc)
    )
    
    // (H62b)
    const ξ_ = Mc => min(2.5, max(0.4, $.R.mHe_(Mc) / Rx_(Mc)))
    
    // (H62)
    const λ_ = (Mc, τ) => ((τ - τx) / (1 - τx)) ** ξ_(Mc)
    
    // (H63)
    const _λ_ = (Mc, τ) => ((τx - τ) / τx) ** 3
    
    // (H61)
    $.L.CHeB_ = (Mc, τ) => 
      in_range(τx, τ, 1) ? Lx_(Mc) * (($.L.BAGB/Lx_(Mc))**λ_(Mc)) 
      : Lx_(Mc) * (($.L.HeI/Lx_(Mc)) ** _λ_(Mc))
    
    const Rmin_ = Mc => min($.R.mHe_(Mc), Rx_(Mc))
    
    const τy = $.LI_H(1, τ_bl)
    const Ly = $.LI_H($.L.BAGB, NaN)
    const Ry = $.R.AGB_(Ly)
    
    // (H65)
    const ρ_ = (Mc, τ) => 
      (ln(Ry / Rmin_(Mc)) ** (1/3)) * ((τ-τx)/(τy - τx))
      - (ln(Rx / Rmin_(Mc)) ** (1/3)) * ((τy - τ)/(τy - τx))
    
    // (H64)
    $.R.CHeB_ = (Mc, τ) =>
      in_range(0, τ, τx) ? $.R.GB_(L_(Mc, τ))
      : in_range(τy, τ, 1) ? $.R.AGB_(L_(Mc, τ))
      : in_range(τx, τ, τy) ? Rmin_(Mc) * exp(abs(ρ_(Mc, τ)) ** 3)
      : NaN
    
    // (H66)
    $.Mc.BAGB = (b36*(M**b37) + b38) ** (1/4)
    
    // (H67)
    $.Mc.CHeB_ = τ => mix($.Mc.HeI, $.Mc.BAGB, τ)
  }
  
  {
    // (H p.13)
    
    $.t.BAGB = $.t.HeI + $.t.He_($.Mc.CO)
  }
 
  $.bubble = {}
  $.color = ""
  
  stars[id] = $
  star_update(id, 0)
}

const bubbles = []
const colors = []
const borders = []

const star_update = (id, t) => {
  const $ = stars[id]
  const phase = in_range(0, t, $.t.MS) ? ($.M < 0.7 ? phases.C_MS : phases.MS)
  : in_range($.t.MS, t, $.t.BGB) ? phases.HG
  : in_range($.t.BGB, t, $.t.HeI) ? phases.GB
  : in_range($.t.HeI, t, $.t.BAGB) ? phases.CHeB
  : in_range($.t.BAGB, t, $.t.DU) ? phases.EAGB
  : phases.R
  
 // relative time
  
  switch(phase){
    // Main sequence
    case phases.C_MS:
    case phases.MS: {
      const τ = $.τ.MS_(t)
      const τ1 = $.τ.MS_1_(t)
      const τ2 = $.τ.MS_2_(t)
      
      const L = $.L.MS_(τ, τ1, τ2)
      const R = $.R.MS_(τ, τ1, τ2)

      $.L.now = L
      $.R.now = R
      $.border = "white"
      $.opacity = "ff"
      break
    }
    
    // Hertzsprung gap
    case phases.HG: {
      const τ = $.τ.HG_(t)
      
      const Mc = $.Mc.HG_(τ)
      
      const L = $.L.HG_(τ)
      const R = $.R.HG_(Mc, τ)

      $.L.now = L
      $.R.now = R
      $.border = "green"
      $.opacity = "ff"
      break
    }
    case phases.GB: {
      const τ = $.τ.GB_(t)
      
      const Mc = $.Mc.GB_(t, τ)

      const L = $.L.GB_(τ)
      const R = $.R.GB_(L)  
      
      $.R.now = R
      $.L.now = L
      $.border = "blue"
      $.opacity = "88"
      break
    }
    case phases.CHeB: {
      const τ = $.τ.CHeB_(t)
      
      const Mc = $.Mc.CHeB_(τ)
      
      const L = $.L.CHeB_(Mc, τ)
      const R = $.R.CHeB_(Mc, τ)
      
      $.L.now = L
      $.R.now = R
      $.border = "pink"
      $.opacity = "88"
      break
    }
    // no remnant
    case phases.R: {
      $.R.now = 1
      $.border = "black"
      $.opacity = "11"
      break
    }
    default: {
      $.R.now = $.R.ZAMS
      $.L.now = $.L.ZAMS
      $.border = "red"
      $.opacity = "ff"
      break
    }
  }
  if(phase.index < 15) {
    //console.log(phase)
    //console.log(JSON.stringify($,"",2))
  }
 
  $.T.now = radius_lum_to_temp($.R.now, $.L.now)
  $.color = temp_to_col($.T.now)

  $.bubble.x = $.T.now
  $.bubble.y = $.L.now
  $.bubble.r = $.R.now*4
  $.bubble.mass = $.M.ZAMS.toPrecision(2)
  
  bubbles[id] = $.bubble
  colors[id] = $.color + $.opacity
  borders[id] = $.border
}

for(let i = 0; i < n_stars; i++){
  const mass = random_range(min_mass, max_mass)
  
  // Reject unlikely masses
  const test_mass = random_range(min_mass, max_mass)
  //if(initial_mass_function(mass) < initial_mass_function(test_mass)) continue
  
  const metallicity = 0.02
  
  star_init(i, mass, metallicity)
}

Chart.defaults.color = '#ccc'
Chart.defaults.borderColor = '#444'
Chart.defaults.maintainAspectRatio = false

Chart.register(ChartDataLabels)

const chart = new Chart(canvas, {
  type: 'bubble',
  plugins: [ChartDataLabels],
  data: {
    datasets: [{
      label: 'Stars',
      data: bubbles,
      backgroundColor: colors,
      borderColor: borders,
      borderWidth: 1
    }],
  },
  options: {
    clip: 0,
    animation: { duration: 0 },
    borderColor: "white",
    plugins: {
      datalabels: {
        align: "top",
        offset: 10,
        formatter: bubble => bubble.mass
      }
    },
    layout: {
      autoPadding: false,
    },
    scales: {
      x: {
        type: 'logarithmic',
        title: { display, text: 'Surface temperature (Kelvins)' },
        position: 'top',
        min: max_temp, max: min_temp,
        reverse: true,
        ticks: { 
          callback: value => classes[value] + "0: " + value,
          minRotation: 30
        },
        afterBuildTicks: axis => axis.ticks = Object.keys(classes).map(v => ({ value: parseInt(v) })),
        grid: { drawOnChartArea: false },
      },
      x1: {
        type: 'linear',
        title: { display, text: 'Blue light versus visible light (B−V index)' },
        position: 'bottom',
        min: min_bv, max: max_bv,
        grid: { drawOnChartArea: true },
      },
      // x2: {
      //   type: 'category',
      //   position: 'top',
      //   labels: Object.values(classes),
      //   reverse: true,
      // },
      y: {
        type: 'logarithmic',
        title: { display, text: 'Luminosity in Suns (L⊙)' },
        display: true,
        position: 'right',
        min: min_sol_lum, max: max_sol_lum,
        grid: { drawOnChartArea: false },
      },
      y1: {
        type: 'linear',
        position: 'left',
        title: { display, text: 'Hipparchus’s scale (Absolute magnitude)' },
        min: max_mag, max: min_mag,
        reverse: true,
        grid: { drawOnChartArea: true },
      },
    },
    onClick: (e) => {
        const canvasPosition = Chart.helpers.getRelativePosition(e, chart)

        // Substitute the appropriate scale IDs
        const dataX = chart.scales.x.getValueForPixel(canvasPosition.x)
        const dataY = chart.scales.y.getValueForPixel(canvasPosition.y)
    }
  }
})

const $time = document.getElementById("time")
const draw = async (now) => {
  const time = 50*now/1000
  $time.value = time.toFixed(2)
  await Promise.all(Object.keys(stars).map(id => star_update(id, time)))
  chart.update()
  requestAnimationFrame(draw)
}
requestAnimationFrame(draw)
    </script>
  </body>
</html>
