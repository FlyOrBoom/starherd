<html>
  <head>
    <title>Starherd</title>
    <meta charset=UTF-8>
    <meta name=description content="Evolving H-R diagram">
    <meta name=keywords content=astronomy>
    <meta name=author content=Xing>
    <meta name=viewport content="width=device-width, initial-scale=1">
    <link rel=stylesheet href=style.css>
    <link rel='shortcut icon' type=image/png href=favicon.png>
    <style>
html, body {
  margin: 0;
  width: 100%;
  height: 100%;
  background: #222;
  color: white;
  font-size: 16px;
}
    </style>
  </head>
  <body>
    <canvas id="hr"></canvas>
    <label>
      <input id="time" type="number" min="0" max="1e8" value="0" step="1">
      <span> million years</span>
    </label>
    <h1>Starherd</h1>
    <p> 
      A stellar evolution visualizer by Xing, based on 
      <a href="https://arxiv.org/abs/astro-ph/0001295">"Comprehensive analytic formulae for stellar evolution as a function of mass and metallicity"</a> 
      by Hurley, Pols &amp; Tout, and 
      <a href="https://ui.adsabs.harvard.edu/abs/1996MNRAS.281..257T/abstract">"Zero-age main-sequence radii and luminosities as analytic functions of mass and metallicity"</a> 
      by Tout, Pols, Eggleton, &amp; Han.
    </p>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script>
"use strict"

const canvas = document.getElementById('hr')

// Math
const random_range = (a, b) => a + (b - a) * Math.random()
const in_range = (a, x, b) => (a <= x) && (x <= b)
const log10 = (x) => Math.log(x)/Math.log(10.0)
const exp = (x) => Math.exp(x)
const exp10 = (x) => Math.pow(10, x)
const max = (a,b) => Math.max(a,b)
const min = (a,b) => Math.min(a,b)
const clamp = (a,x,b) => min(max(x,a),b)
const mix = (a,b,x) => a*(1-x) + b*x
const interpolate = (x) => (x0, x1) => (v0, v1) =>
  (x < x0) ? v0 : (x > x1) ? v1 : mix(v0, v1, (x-x0)/(x1-x0))
const sqrt = (x) => Math.sqrt(x)
const cbrt = (x) => Math.cbrt(x)
const int_range = (n) => Array(n).fill(0).map((_, i) => i)

// Constants
const PI = Math.PI
const STEFAN = 5.670374419e-8
const L_sun = 3.86e+26 // watts
const R_sun = 6.9634e+8 // meters
const Z_sun = 0.02
const A_H = 1.44e-5 // rate of hydrogen fusion in CNO cycle

// Conversions
const abs_mag_to_sol_lum = (M) => 
  Math.pow(100, -M/5)
  
const bv_to_temp = (i) => 
  4600 * (1/(0.92*i + 1.7) + 1/(0.92*i + 0.62))
  
const radius_lum_to_temp = (R, L) => 
  ( L*L_sun / ((4*PI*R*R*R_sun*R_sun) * STEFAN) ) ** (1/4)
  
const temp_to_col = (T) => {
  const blackbody = [
   {temp:1000,col:"#ff3800"},{temp:1200,col:"#ff5300"},{temp:1400,col:"#ff6500"},
   {temp:1600,col:"#ff7300"},{temp:1800,col:"#ff7e00"},{temp:2000,col:"#ff8912"},
   {temp:2200,col:"#ff932c"},{temp:2400,col:"#ff9d3f"},{temp:2600,col:"#ffa54f"},
   {temp:2800,col:"#ffad5e"},{temp:3000,col:"#ffb46b"},{temp:3200,col:"#ffbb78"},{
    temp:3400,col:"#ffc184"},{temp:3600,col:"#ffc78f"},{temp:3800,col:"#ffcc99"},
    {temp:4000,col:"#ffd1a3"},{temp:4200,col:"#ffd5ad"},{temp:4400,col:"#ffd9b6"},{temp:4600,col:"#ffddbe"},{temp:4800,col:"#ffe1c6"},{temp:5000,col:"#ffe4ce"},{temp:5200,col:"#ffe8d5"},{temp:5400,col:"#ffebdc"},{temp:5600,col:"#ffeee3"},{temp:5800,col:"#fff0e9"},{temp:6000,col:"#fff3ef"},{temp:6200,col:"#fff5f5"},{temp:6400,col:"#fff8fb"},{temp:6600,col:"#fef9ff"},{temp:6800,col:"#f9f6ff"},{temp:7000,col:"#f5f3ff"},{temp:7200,col:"#f0f1ff"},{temp:7400,col:"#edefff"},{temp:7600,col:"#e9edff"},{temp:7800,col:"#e6ebff"},{temp:8000,col:"#e3e9ff"},{temp:8200,col:"#e0e7ff"},{temp:8400,col:"#dde6ff"},{temp:8600,col:"#dae4ff"},{temp:8800,col:"#d8e3ff"},{temp:9000,col:"#d6e1ff"},{temp:9200,col:"#d3e0ff"},{temp:9400,col:"#d1dfff"},{temp:9600,col:"#cfddff"},{temp:9800,col:"#cedcff"},{temp:10000,col:"#ccdbff"},{temp:10200,col:"#cadaff"},{temp:10400,col:"#c9d9ff"},{temp:10600,col:"#c7d8ff"},{temp:10800,col:"#c6d8ff"},{temp:11000,col:"#c4d7ff"},{temp:11200,col:"#c3d6ff"},{temp:11400,col:"#c2d5ff"},{temp:11600,col:"#c1d4ff"},{temp:11800,col:"#c0d4ff"},{temp:12000,col:"#bfd3ff"},{temp:12200,col:"#bed2ff"},{temp:12400,col:"#bdd2ff"},{temp:12600,col:"#bcd1ff"},{temp:12800,col:"#bbd1ff"},{temp:13000,col:"#bad0ff"},{temp:13200,col:"#b9d0ff"},{temp:13400,col:"#b8cfff"},{temp:13600,col:"#b7cfff"},{temp:13800,col:"#b7ceff"},{temp:14000,col:"#b6ceff"},{temp:14200,col:"#b5cdff"},{temp:14400,col:"#b5cdff"},{temp:14600,col:"#b4ccff"},{temp:14800,col:"#b3ccff"},{temp:15000,col:"#b3ccff"},{temp:15200,col:"#b2cbff"},{temp:15400,col:"#b2cbff"},{temp:15600,col:"#b1caff"},{temp:15800,col:"#b1caff"},{temp:16000,col:"#b0caff"},{temp:16200,col:"#afc9ff"},{temp:16400,col:"#afc9ff"},{temp:16600,col:"#afc9ff"},{temp:16800,col:"#aec9ff"},{temp:17000,col:"#aec8ff"},{temp:17200,col:"#adc8ff"},{temp:17400,col:"#adc8ff"},{temp:17600,col:"#acc7ff"},{temp:17800,col:"#acc7ff"},{temp:18000,col:"#acc7ff"},{temp:18200,col:"#abc7ff"},{temp:18400,col:"#abc6ff"},{temp:18600,col:"#aac6ff"},{temp:18800,col:"#aac6ff"},{temp:19000,col:"#aac6ff"},{temp:19200,col:"#a9c6ff"},{temp:19400,col:"#a9c5ff"},{temp:19600,col:"#a9c5ff"},{temp:19800,col:"#a9c5ff"},{temp:20000,col:"#a8c5ff"},{temp:20200,col:"#a8c5ff"},{temp:20400,col:"#a8c4ff"},{temp:20600,col:"#a7c4ff"},{temp:20800,col:"#a7c4ff"},{temp:21000,col:"#a7c4ff"},{temp:21200,col:"#a7c4ff"},{temp:21400,col:"#a6c3ff"},{temp:21600,col:"#a6c3ff"},{temp:21800,col:"#a6c3ff"},{temp:22000,col:"#a6c3ff"},{temp:22200,col:"#a5c3ff"},{temp:22400,col:"#a5c3ff"},{temp:22600,col:"#a5c3ff"},{temp:22800,col:"#a5c2ff"},{temp:23000,col:"#a4c2ff"},{temp:23200,col:"#a4c2ff"},{temp:23400,col:"#a4c2ff"},{temp:23600,col:"#a4c2ff"},{temp:23800,col:"#a4c2ff"},{temp:24000,col:"#a3c2ff"},{temp:24200,col:"#a3c1ff"},{temp:24400,col:"#a3c1ff"},{temp:24600,col:"#a3c1ff"},{temp:24800,col:"#a3c1ff"},{temp:25000,col:"#a3c1ff"},{temp:25200,col:"#a2c1ff"},{temp:25400,col:"#a2c1ff"},{temp:25600,col:"#a2c1ff"},{temp:25800,col:"#a2c1ff"},{temp:26000,col:"#a2c0ff"},{temp:26200,col:"#a2c0ff"},{temp:26400,col:"#a1c0ff"},{temp:26600,col:"#a1c0ff"},{temp:26800,col:"#a1c0ff"},{temp:27000,col:"#a1c0ff"},{temp:27200,col:"#a1c0ff"},{temp:27400,col:"#a1c0ff"},{temp:27600,col:"#a1c0ff"},{temp:27800,col:"#a0c0ff"},{temp:28000,col:"#a0bfff"},{temp:28200,col:"#a0bfff"},{temp:28400,col:"#a0bfff"},{temp:28600,col:"#a0bfff"},{temp:28800,col:"#a0bfff"},{temp:29000,col:"#a0bfff"},{temp:29200,col:"#a0bfff"},{temp:29400,col:"#9fbfff"},{temp:29600,col:"#9fbfff"},{temp:29800,col:"#9fbfff"},{temp:1e10,col:"#9fbfff"}
  ]
  return (blackbody.find(({temp})=> temp > T) || {col: "green"}).col
}

// Probability density function of stars' initial masses
const initial_mass_function = M => (
  in_range(0.08, M, 0.50) ? 0.035 * Math.pow(M, -1.3)
  : in_range (0.50, M, 1.00) ? 0.019 * Math.pow(M, -2.2)
  : in_range (1.00, M, 100) ? 0.019 * Math.pow(M, -2.7)
  : 0
)

// Zeta function of metallicity Z
const phases = {
  C_MS: { name: "Main sequence below 0.7 M", index: 0, },
  MS: { name: "Main sequence above 0.7 M", index: 1, },
  HG: { name: "Hertzsprung Gap", index: 2, },
  GB: { name: "First Giant Branch", index: 3, },
  CHe_B: { name: "Core Helium Burning", index: 4, },
  EA_GB: { name: "Early Asymptotic Giant Branch", index: 5, },
  TAP_GB: { name: "Thermally Pulsating Asymptotic Giant Branch", index: 6, },
  He_MS: { name: "Naked Helium Star Main Sequence", index: 7, },
  He_HG: { name: "Naked Helium Star Hertzsprung Gap", index: 8, },
  He_GB: { name: "Naked Helium Star Giant Branch", index: 9, },
  He_WD: { name: "Helium White Dwarf", index: 10, },
  CO_WD: { name: "Carbon/Oxygen White Dwarf", index: 11, },
  ONe_WD: { name: "Oxygen/Neon White Dwarf", index: 12, },
  NS: { name: "Neutron Star", index: 13, },
  BH: { name: "Black Hole", index: 14, },
  R: { name: "massless remnant", index: 15, },
}

const polynomial = x => coefficients => 
  coefficients.reduce((sum, coefficient, degree) => 
    sum + coefficient * (x**degree)
  , 0)

const rational = x => (...pairs) =>
  pairs.reduce((sum, [coefficient, exponent]) => 
    sum + coefficient * (x ** exponent)
  , 0)

const fit = x => (...numerator) => (...denominator) =>
  rational(x)(...numerator) / rational(x)(...denominator)

const from_coefficients = x => (...coefficients) =>
  coefficients.map(polynomial(x))

let min_bv = -0.5, max_bv = +3
let min_temp = bv_to_temp(min_bv), max_temp = bv_to_temp(max_bv)

let min_mag = +10, max_mag = -20
let min_sol_lum = abs_mag_to_sol_lum(min_mag), max_sol_lum = abs_mag_to_sol_lum(max_mag)

let min_mass = 0.1, max_mass = 10

const display = true

const bubble_config = {
  count: 7,
  rmin: 5,
  rmax: 15,
  min: 0,
  max: 100
}

const stars = {}

const star_init = (id, M, Z) => {
  const $ = { 
    id, 
    M: { ZAMS: M }, // mass
    Mc: { }, // core mass
    
    X: 0.76 - 3*Z, // hydrogen abunance (T p.1)
    Y: 0.24 + 2*Z, // helium abundance (T p.1)
    Z: Z, // metallicity (T p.1)
    σ: log10(Z), // log metallicity (H Appendix)
    ζ: log10(Z/Z_sun), // relative log metallicity (H Appendix)
    
    L: { }, // luminosity
    R: { }, // radius
    T: { }, // temperature
    t: { }, // time
    τ: { }, // relative time
    _: { }, // misc
  }
 
  
  $.polynomial = polynomial($.ζ)
  $.fit = fit($.M.ZAMS)
  $.from_coefficients = from_coefficients($.ζ)
  
  // Zero-age main sequence mass and radius
  
  // (T2)
  {
    const [ a1, a2, a3, a4, a5, a6, a7, a8, a9 ] = $.from_coefficients(
      [ 1.715359, 0.62246212, -0.92557761, -1.16996966, -0.30631491 ], 
      [ 6.597788, -0.42450044, -12.13339427, -10.73509484, -2.51487077 ],
      [ 10.08855, -7.11727086, -31.67119479, -24.24848322, -5.33608972 ],
      [ 1.012495, 0.3269969, -0.00923418, -0.03876858, -0.0041275 ],
      [ 0.07490166, 0.02410413, 0.07233664, 0.03040467, 0.00197741 ],
      [ 0.01077422, 0, 0, 0, 0 ],
      [ 3.082234, 0.9447205, -2.15200882, -2.49219496, -0.63848738 ],
      [ 17.84778, -7.4534569, -48.96066856, -40.05386135, -9.09331816 ],
      [ 0.00022582, -0.00186899, 0.00388783, 0.00142402, -0.00007671 ]
    ) 
    $.R.ZAMS = $.fit
    ([a1, 2.5], [a2, 6.5], [a3, 11], [a4, 19], [a5, 19.5])
    ([a6, 0], [a7, 2], [a8, 8.5], [1, 18.5], [a9, 19.5])
  }
  
  // (T1)
  {
    const [ a1, a2, a3, a4, a5, a6, a7 ] = $.from_coefficients(
      [ 0.3970417, -0.32913574, 0.34776688, 0.37470851, 0.09011915 ],
      [ 8.527626, -24.41225973, 56.43597107, 37.06152575, 5.4562406 ],
      [ 0.00025546, -0.00123461, -0.00023246, 0.00045519, 0.00016176 ],
      [ 5.432889, -8.62157806, 13.44202049, 14.51584135, 3.39793084 ],
      [ 5.563579, -10.32345224, 19.4432298, 18.97361347, 4.16903097 ],
      [ 0.7886606, -2.90870942, 6.54713531, 4.05606657, 0.53287322 ],
      [ 0.00586685, -0.01704237, 0.03872348, 0.02570041, 0.00383376 ]
    )
    $.L.ZAMS = $.fit
    ([a1, 5.5], [a2, 11])
    ([a3, 0], [1, 3], [a4, 5], [a5, 7], [a6, 8], [a7, 9.5])
  }
  
  // (H1, H2, H3)
  {
    // (H1)
    // the initial mass above which a hook appears in the main-sequence
    $.M.hook = 1.0185 + 0.16015*$.ζ + 0.0892*$.ζ*$.ζ

    // (H2)
    // the maximum initial mass for which He ignites degenerately in a helium flash
    $.M.HeF = 1.995 + 0.25*$.ζ + 0.087*$.ζ*$.ζ

    // (H3)
    // the maximum initial mass for which He ignites on the first giant branch
    $.M.FGB = 13.048 * ((Z/0.02)**0.06) / (1 + 0.0012*((0.02/Z)**1.27))

    // where the mass of the convective envelope MCE first exceeds a set fraction of the envelope mass ME
    $.ratio_CE_E = (M < $.M.HeF) ? (2/5) : (1/3)
  }
  
  // [5.1] Main-sequence and Hertzsprung gap
  
  // (H4)
  {
    const [ a1, a2, a3, a4, a5 ] = $.from_coefficients(
      [1.593890e+3, 2.053038e+3, 1.231226e+3, 2.327785e+2],
      [2.706708e+3, 1.483131e+3, 5.772723e+2, 7.411230e+1],
      [1.466143e+2, -1.048442e+2, -6.795374e+1, -1.391127e+1],
      [4.141960e-2, 4.564888e-2, 2.958542e-2, 5.571483e-3],
      [3.426349e-1]
    )
    $.t.BGB = $.t.HeI = $.fit
    ([a1, 0], [a2, 4], [a3, 5.5], [1, 7])
    ([a4, 2], [a5, 7])
  }
  
  // (H5, H6, H7)
  {
    const [ a6, a7, a8, a9, a10 ] = $.from_coefficients(
      [1.949814e+1, 1.758178e+0, -6.008212e+0, -4.470533e+0],
      [4.903830e+0],
      [5.212154e-2, 3.166411e-2, -2.750074e-3, -2.271549e-3],
      [1.312179e+0, -3.294936e-1, 9.231860e-2, 2.610989e-2],
      [8.073972e-1]
    )
    
    // (H7)
    const µ = max(0.5, 1 - 0.01 * max(a6 / (M**a7), a8 + a9/(M**a10)))
    
    $.t.hook = µ * $.t.BGB
    
    // (H6)
    const x = max(0.95, min(0.95 - 0.03*($.ζ + 0.30103), 0.99))
    
    // (H5)
    $.t.MS = max($.t.hook, x * $.t.BGB)
  }
  
  // (H8)
  {
    const [ _a11, _a12, a13, a14, a15, a16 ] = $.from_coefficients(
      [1.031538e+0, -2.434480e-1, 7.732821e+0, 6.460705e+0, 1.374484e+0],
      [1.043715e+0, -1.577474e+0, -5.168234e+0, -5.596506e+0, -1.299394e+0],
      [7.859573e+2, -8.542048e+0, -2.642511e+1, -9.585707e+0],
      [3.858911e+3, 2.459681e+3, -7.630093e+1, -3.486057e+2, -4.861703e+1],
      [2.888720e+2, 2.952979e+2, 1.850341e+2, 3.797254e+1],
      [7.196580e0, 5.613746e-1, 3.805871e-1, 8.398728e-2],
    )
    const a11 = _a11 * a14
    const a12 = _a12 * a14
    $.L.TMS = $.fit
    ([a11, 3], [a12, 4], [a13, a16 + 1.8])
    ([a14, 0], [a15, 5], [1, a16])
  }
  
  // (H9)
  {
    const [ _a18, _a19, a20, a21, a22, a23, a24, a25, a26 ] = $.from_coefficients(
      [2.187715e-1, -2.154437e+0, -3.768678e+0, -1.975518e+0, -3.021475e-1],
      [1.466440e+0, 1.839725e+0, 6.442199e+0, 4.023635e+0, 6.957529e-1],
      [2.652091e+1, 8.178458e+1, 1.156058e+2, 7.633811e+1, 1.950698e+1],
      [1.472103e+0, -2.947609e+0, -3.312828e+0, -9.945065e-1],
      [3.071048e+0, -5.679941e+0, -9.745523e+0, -3.594543e+0],
      [2.617890e+0, 1.019135e+0, -3.292551e-2, -7.445123e-2],
      [1.075567e-2, 1.773287e-2, 9.610479e-3, 1.732469e-3],
      [1.476246e+0, 1.899331e+0, 1.195010e+0, 3.035051e-1],
      [5.502535e+0, -6.601663e-2, 9.968707e-2, 3.599801e-2],
    )
    const a17 = exp10(max(0.097 - 0.1072*($.σ + 3), max(0.097, min(0.1461, 0.1461 + 0.1237*($.σ + 2)))))
    const a18 = _a18 * a20
    const a19 = _a19 * a20
    const c1 = -8.672073e-2
    const M_star = a17 + 0.1

    $.R.TMS = interpolate (M) (a17, M_star) (
      fit (max(M, a17)) ([a18, 0], [a19, a21]) ([a20, 0], [1, a22]),
      fit (min(M_star, M)) ([c1, 3], [a23, a26], [a24, a26+1.5]) ([a25, 0], [1, 5])
    )
    
    if(M < 0.5) $.R.TMS = max($.R.TMS, 1.5*$.R.ZAMS)
  }
  
  // (H10)
  {
    const [ a27, a28, _a29, a30, a31, a32 ] = $.from_coefficients(
      [9.511033e+1, 6.819618e+1, -1.045625e+1, -1.474939e+1],
      [3.113458e+1, 1.012033e+1, -4.650511e+0, -2.463185e+0],
      [1.413057e+0, 4.578814e-1, -6.850581e-2, -5.588658e-2],
      [3.910862e+1, 5.196646e+1, 2.264970e+1, 2.873680e+0],
      [4.597479e+0, -2.855179e-1, 2.709724e-1],
      [6.682518e+0, 2.827718e-1, -7.294429e-2],
    )
    const a29 = _a29 ** a32
    
    const c2 = 9.301992
    const c3 = 4.637345
    
    $.L.BGB_ = M => fit(M)
      ([a27, a31], [a28, c2])
      ([a29, 0], [a30, c3], [1, a32])
    $.L.BGB = $.L.BGB_(M)
  }
  
  // (H11, H12, H13, H14, H15, H24)
  {
    // (H11)
    $.τ.MS_ = t => t / $.t.MS

    // (H12)
    $.L.MS_ = (τ, τ1, τ2) => $.L.ZAMS * exp10(
      $.L.α*(τ) 
      + $.L.β*(τ**$.η)
      + (log10($.L.TMS/$.L.ZAMS) - $.L.α - $.L.β)*(τ*τ)
      - $.L.Δ*(τ1*τ1 - τ2*τ2)
    )

    // (H13, H24)
    $.R.MS_ = (τ, τ1, τ2) => max(
      $.R.ZAMS * exp10(
        $.R.α*(τ) 
        + $.R.β*(τ**10)
        + $.γ*(τ**40)
        + (log10($.R.TMS/$.R.ZAMS) - $.R.α - $.R.β - $.γ)*(τ*τ*τ)
        - $.R.Δ*(τ1*τ1*τ1 - τ2*τ2*τ2)
      ), 
      0.0258 * ((1.0 + $.X)**(5/3)) * (M**(-1/3))
    )
    
    const ε = 0.01

    // (H14)
    $.τ.MS_1_ = t => min(1.0, t/$.t.hook)

    // (H15)
    $.τ.MS_2_ = t => clamp(0.0, (t - (1.0 - ε)*$.t.hook)/(ε * $.t.hook), 1.0)
  }
  
  // (H16)
  {
    const [ a34, a35, a36, a37 ] = $.from_coefficients(
      [1.910302e-1, 1.158624e-1, 3.348990e-2, 2.599706e-3],
      [3.931056e-1, 7.277637e-2, -1.366593e-1, -4.508946e-2],
      [3.267776e-1, 1.204424e-1, 9.988332e-2, 2.455361e-2],
      [5.990212e-1, 5.570264e-2, 6.207626e-2, 1.777283e-2],
    )
    const _a33 = min(1.4, 1.5135 + 0.3769 * $.ζ)
    const a33 = max(0.6355 - 0.4192 * $.ζ, max(1.25, _a33))
    
    const B = M => min(a34 / (M**a35), a36 / (M**a37))
    
    $.L.Δ = ( M < $.M.hook ) ? 0
    : in_range($.M.hook, M, a33) ? B*(((M - $.M.hook)/(a33 - $.M.hook))**0.4)
    : ( M > a33 ) ? B(M)
    : 0
  }
  
  // (H17)
  {
    const [ a38, a39, a40, a41, _a42, a43, _a44 ] = $.from_coefficients(
      [7.330122e-1, 5.192827e-1, 2.316416e-1, 8.346941e-3],
      [1.172768e+0, -1.209262e-1, -1.193023e-1, -2.859837e-2],
      [3.982622e-1, -2.296279e-1, -2.262539e-1, -5.219837e-2],
      [3.571038e+0, -2.223625e-2, -2.611794e-2, -6.359648e-3],
      [1.9848e+0, 1.1386e+0, 3.5640e-1],
      [6.300e-2, 4.810e-2, 9.840e-3],
      [1.200e+0, 2.450e+0],
    )
    const a42 = min(1.25, max(1.1, _a42))
    const a44 = min(1.3, max(0.45, _a44))
    
    const B = M => fit(M)([a38, 0], [a39, 3.5])([a40, 3], [1, a41]) - 1

    $.R.Δ = ( M < $.M.hook ) ? 0
    : in_range($.M.hook, M, a42) ? a43 * sqrt((M - $.M.hook)/(a42 - $.M.hook))
    : in_range(a42, M, 2.0) ? a43 + (B(2.0) - a43)*(((M-a42)/(2-a42))**a44)
    : ( M > 2.0 ) ? B(M)
    : 0.0
  }

   // (H18)
  $.η = (Z > 0.0009 || M < 10) ? 10 : 20
  
  // (H19)
  {
    const [ a45, a46, a47, a48, _a49, _a50, _a51, _a52, _a53 ] = $.from_coefficients(
      [2.321400e-1, 1.828075e-3, -2.232007e-2, -3.378734e-3],
      [1.163659e-2, 3.427682e-3, 1.421393e-3, -3.710666e-3],
      [1.048020e-2, -1.231921e-2, -1.686860e-2, -4.234354e-3],
      [1.555590e+0, -3.223927e-1, -5.197429e-1, -1.066441e-1],
      [9.7700e-2, -2.3100e-1, -7.5300e-2],
      [2.4000e-1, 1.8000e-1, 5.9500e-1],
      [3.3000e-1, 1.3200e-1, 2.1800e-1],
      [1.1064e+0, 4.1500e-1, 1.8000e-1],
      [1.1900e+0, 3.7700e-1, 1.7600e-1],
    )
    const a49 = max(_a49, 0.145)
    const a50 = min(_a50, 0.306 + 0.053 * $.ζ)
    const a51 = min(_a51, 0.3625 + 0.062 * $.ζ)
    const a52 = (Z > 0.01) ? clamp(0.9, _a52, 1.0) : max(_a52, 0.9)
    const a53 = (Z > 0.01) ? clamp(1.0, _a53, 1.1) : max(_a53, 1.0)
    
    const B = M => fit(M)([a45, 0], [a46, a48])([1, 0.4], [a47, 1.9])
    
    $.L.α = ( M < 0.5) ? a49
    : in_range(0.5, M, 0.7) ? a49 + 5.0*(0.3 - a49)*(M - 0.5)
    : in_range(0.7, M, a52) ? 0.3 + (a50 - 0.3)*(M - 0.7)/(a52 - 0.7)
    : in_range(a52, M, a53) ? a50 + (a51 - a50)*(M - a52)/(a53 - a52)
    : in_range(a53, M, 2.0) ? a51 + (B(2.0) - a51)*(M - a53)/(2.0 - a53)
    : ( M > 2.0 ) ? B(M)
    : 0.0
  }
  
  // (H20)
  {
    const coefficients = [
      [3.855707e-1, -6.104166e-1, 5.676742e+0, 1.060894e+1, 5.284014e+0],
      [3.579064e-1, -6.442936e-1, 5.494644e+0, 1.054952e+1, 5.280991e+0],
      [9.587587e-1, 8.777464e-1, 2.017321e-1],
      [1.5135e+0, 3.7690e-1],
    ]
    const p = n => $.polynomial(coefficients[n])
    const [ a54, a55, a56, _a57 ] = int_range(4).map(p)
    const a57 = clamp(0.6355 - 0.4192*$.ζ, max(1.25, _a57), 1.4)
    
    const B = M => max(0.0, a54 - a55*(M**a56))
    
    $.L.β = (M > a57 && B(M) > 0.0) ? max(0.0, B(a57) - 10.0*B(a57)*(M-a57))
    : B(M)
  }
  
  // (H21)
  {
    const [ a58, a59, a60, a61, _a62, _a63, __a64, a65, _a66, a67, __a68 ] = $.from_coefficients(
      [4.907546e-1, -1.683928e-1, -3.108742e-1, -7.202918e-2],
      [4.537070e+0, -4.465455e+0, -1.612690e+0, -1.623246e+0],
      [1.796220e+0, 2.814020e-1, 1.423325e+0, 3.421036e-1],
      [2.256216e+0, 3.773400e-1, 1.537867e+0, 4.396373e-1],
      [8.4300e-2, -4.7500e-2, -3.5200e-2],
      [7.3600e-2, 7.4900e-2, 4.4260e-2],
      [1.3600e-1, 3.5200e-2],
      [1.564231e-3, 1.653042e-3, -4.439786e-3, -4.951011e-3, -1.216530e-3],
      [1.4770e+0, 2.9600e-1],
      [5.210157e+0, -4.143695e+0, -2.120870e+0],
      [1.1160e+0, 1.6600e-1],
    )
    const a62 = max(0.065, _a62)
    const a63 = (Z < 0.004) ? min(0.055, _a63) : _a63
    const _a64 = max(0.091, min(0.121, __a64))
    const a66 = clamp(0.8, max(_a66, min(1.6, 0.308 - 1.046 * $.ζ)), 0.8 - 2.0*$.ζ)
    const _a68 = max(0.9, min(__a68, 1.0))
        
    const B = M => fit(M)([a58, a60])([a59, a61])
    const a64 = (_a68 > a66) ? B(a66) : _a64
    const a68 = min(_a68, a66)
    
    $.R.α = in_range(a66, M, a67) ? B(M)
    : (M < 0.5) ? a62
    : in_range(0.5, M, 0.65) ? a62 + (a63-a62)*(M-0.5) / 0.15
    : in_range(0.65, M, a68) ? a63 + (a64-a63)*(M-0.65) / (a68 - 0.65)
    : in_range(a68, M, a66) ? a64 + (B(a66) - a64)*(M - a68) / (a66 - a68)
    : (M > a67) ? B(a67) + a65*(M - a67)
    : 0.0
  }
  
  // (H22)
  {
    const [ a69, a70, a71, _a72, a73, _a74 ] = $.from_coefficients(
      [1.071489e+0, -1.164852e-1, -8.623831e-2, -1.582349e-2],
      [7.108492e-1, 7.935927e-1, 3.926983e-1, 3.622146e-2],
      [3.478514e+0, -2.585474e-2, -1.512955e-2, -2.833691e-3],
      [9.132108e-1, -1.653695e-1, 3.636784e-2],
      [3.969331e-3, 4.539076e-3, 1.720906e-3, 1.897857e-4],
      [1.600e+0, 7.640e-1, 3.322e-1]
    )
    const a72 = (Z>0.01) ? max(_a72, 0.95) : a72
    const a74 = clamp(1.4, _a74, 1.6)
    
    const B = M => fit(M)([a69, 3.5])([a70, 0], [1, a71])
    $.R.β = (M < 1.0) ? 1.06
    : in_range(1.0, M, a74) ? 1.06 + (a72 - 1.06)*(M - 1.0)/(a74 - 1.06)
    : in_range(a74, M, 2.0) ? a74 + (B(2.0) - a72)*(M - a74)/(2.0 - a74)
    : (M > 16.0) ? B(16.0) + a73*(M - 16.0)
    : 0.0
  }
  
  // (H23)
  {
    const [ _a75, _a76, _a77, _a78, _a79, _a80, _a81 ] = $.from_coefficients(
      [8.109e-1, -6.282e-1],
      [1.192334e-2, 1.083057e-2, 1.230969e+0, 1.551656e+0],
      [-1.668868e-1, 5.818123e-1, -1.105027e+1, -1.668070e+1],
      [7.615495e-1, 1.068243e-1, -2.011333e-1, -9.371415e-2],
      [9.409838e+0, 1.522928e+0],
      [-2.7110e-1, -5.7560e-1, -8.3800e-2],
      [2.4930e+0, 1.1475e+0]
    )
    const a75 = max(clamp(1.0, 0.6355 - 0.4192*$.ζ), _a75, 1.27)
    const a76 = max(_a76, -0.1015564 - 0.2161264*$.ζ - 0.05182516*$.ζ*$.ζ)
    const a77 = clamp(-0.3868776 - 0.5457078*$.ζ - 0.146347*$.ζ*$.ζ, _a77, 0.0)
    const a78 = clamp(0.0, _a78, 7.454 + 9.046*$.ζ)
    const a79 = clamp(2.0, -13.3 - 18.6*$.ζ, _a79)
    const a80 = max(0.0585542, _a80)
    const a81 = clamp(0.4, _a81, 1.5)
    
    const B = M => a76 + a77*((M-a78)**a79)
    const C = (a75 < 1.0) ? C = B(1.0) : a80
    $.γ = (M > a75 + 0.1) ? 0.0
    : (M <= 1.0) ? B(M)
    : in_range(1.0, M, a75) ? B(1.0) + (a80 - B(1.0))*(((M-1.0)/(a75-1.0))**a81)
    : in_range(a75, M, a75+1.0) ? C - 10.0*(M-a75)*C
    : 0.0
  }
  
  // (H25, H26, H27, H28, H29, H30) 
  {
    // (H25)
    $.τ.HG_ = t => (t - $.t.MS) / ($.t.BGB - $.t.MS)
    
    // (H26)
    $.L.HG_ = τ => $.L.TMS * (($.L.EHG / $.L.TMS) ** τ)

    // (H27)
    $.R.HG_ = τ => $.R.TMS * (($.R.EHG / $.R.TMS) ** τ)      

    $.Mc.MS = 0.0
    
    // (H28)
    $.Mc.EHG = (M < $.M.HeF) ? $.Mc.GB
    : in_range($.M.HeF, M, $.M.FGB) ? $.Mc.BGB
    : ($.M.FGF < M) ? $.M.c.HeI
    : 0.0
    
    // (H29)
    const ρ = (1.586 + (M**5.25)) / (2.434 + 1.02*(M**5.25))
    $.Mc.TMS = ρ * $.Mc.EHG

    // (H30)
    $.Mc.HG_ = τ => ((1-τ)*$._.ρ + τ) * $.Mc.EHG
  }
  
  // [5.2] First giant branch

   // (H49, H50)
  {
    const [ b9, b10, _b11, b12, _b13 ] = $.from_coefficients(
      [2.751631e+3, 3.557098e+2],
      [-3.820831e-2, 5.872664e-2],
      [1.071738e+2, -8.970339e+1, -3.949739e+1],
      [7.348793e+2, -1.531020e+2, -3.793700e+1],
      [9.219293e+0, -2.005865e+0, -5.561309]
    )
    const b11 = _b11*_b11
    const b13 = _b13*_b13
    
    const B = (M) => fit(M)([b11, 0], [b12, 3.8])([b13, 0], [1, 2])
    const α1 = (b9*($.M.HeF**b10) - B($.M.HeF)) / B($.M.HeF)
    
    // (H49)
    $.L.HeI = (M < $.M.HeF) ? (b9 * (M**b10)) / (1 + α1*exp(15*(M - $.M.HeF))) 
    : B(M)
    
    // (H50)
    $.R.HeI_ = Mc => $.R.GB_($.L.HeI) / $.R.mHe_(Mc)
    
    //console.log($.L.HeI, $.R.HeI)
  }
  
  // (H34, H37, H38, H39, H40, H41, H42, H43)
  {    
    // (H p.10)
    const F = interpolate(M)($.M.HeF, 2.5)
    const p = F(6, 5)
    const q = F(3, 2)
    const B = max(3e+4, 500 + 1.75e+4 * (M**0.6))
    const D0 = 5.37 * 0.135 * $.ζ
    const D = exp10(F(
      D0, max(-1.0, max(0.975*D0 - 0.18*M, 0.5*D0 - 0.06*M))
    ))
    const A_H = exp10(
      max(-4.8, min(-5.7 + 0.8*M, -4.1 + 0.14*M))
    )
    
    // (H34)
    const Mc_ = (p, D, t_inf) => t =>
      ( (p-1) * A_H * D * (t_inf - t) ) ** ( 1 / (1-p) )

    // (H38)
    const Mx = (B/D)**(1/(p - q))
    
    // (H37)
    // L at crossover point
    const Lx = min(
      B * (Mx**q),
      D * (Mx**p)
    )
    
    // (H40)
    const t_inf_1 = $.t.BGB 
      + (1/(A_H * D * (p-1)))
      * ( (D/$.L.BGB)**((p-1)/p) )

    // (H41)
    // t at crossover point
    const tx = t_inf_1
      - (t_inf_1 - $.t.BGB) 
      * ( ($.L.BGB/Lx) ** ((p-1)/p) )

    // (H42)
    const t_inf_2 = tx
      + (1/(A_H * B * (q-1))) 
      * ( (B/Lx) ** ((q-1)/q) )

    // (H37)
    $.L.GB_ = t => min(
      B * (Mc_(p, B, t_inf_1)(t) ** q), 
      D * (Mc_(q, D, t_inf_2)(t) ** p)
    )
    
    // (H39)
    $.M.c_GB_1_ = t => (
      (t < tx) ? Mc_(p, D, t_inf_2) : Mc_(q, B, t_inf_2)
    )(t)
  
    // (H43)  
    const t1 = t_inf_1 
      - (1/(A_H * D * (p-1)))
      * ((D/$.L.HeI)**((p-1)/p))
    const t2 = t_inf_2
      - (1/(A_H * D * (q-1)))
      * ((D/$.L.HeI)**((q-1)/q))
    $.t.HeI = ($.L.HeI < Lx) ? t1 : t2
  }
  
  // (H44)
  {
    const c1 = 9.20925e-5
    const c2 = 5.402216
    const C = $.M.c*($.L.BGB_($.M.HeF) ** 4) - c1*($.M.HeF ** c2)
    
    // (H44)
    $.Mc.BGB = min(
      0.95 * $.Mc.BAGB, 
      ( C + c1*(M**c2) ) ** (1/4)
    )
  }
  
  // (H45)
  {
    // (H p.11)
    $.τ.GB_ = t => (t - $.t.BGB) / ($.t.HeI - $.t.BGB)
    
    // (H45)
    $.Mc.GB_ = (t, τ) => (M > $.M.HeF) ? $.Mc.BGB + ($.Mc.HeI - $.Mc.BGB) * τ
    : $.Mc.GB_1_(t)
  }
  
  // (H46)
  {
    const [ _b1, _b4, b5, _b6, b7 ] = $.from_coefficients(
      [3.9700e-1, 2.8826e-1, 5.2930e-1],
      [9.960283e-1, 8.164393e-1, 2.383830e+0, 2.223436e+0, 8.638115e-1],
      [2.561062e-1, 7.072646e-2, -5.444596e-2, -5.798167e-2, -1.349129e-2],
      [1.157338e+0, 1.467883e+0, 4.299661e+0, 3.130500e+0, 6.992080e-1],
      [4.022765e-1, 3.050010e-1, 9.962137e-1, 7.914079e-1, 1.728098e-1]
    )
    const b1 = min(0.54, _b1)
    const b2 = clamp(-0.04167 + 55.67*Z, exp10(-4.6739 - 0.9394*$.σ), 0.4771 - 9329.21*(Z**2.94))
    const _b3 = exp10(max(-0.1451, -2.2794 - 1.5175*$.σ - 0.254*$.σ*$.σ))
    const b3 = (Z > 0.004) ? max(_b3, 0.7307 + 14265.1 * (Z**3.395)) : _b3
    const b4 = _b4 + 0.1231572 * ($.ζ**5)
    const b6 = _b6 + 0.01640687 * ($.ζ**5)
    
    const A = min(b4 * (M**-b5), b6 * (M**-b7))
    
    // (H46)
    $.R.GB_ = (L) => A * (L**b1 + b2*(L**b3))
  }
  
  // [5.3] Core helium burning
 
  // (H51)
  { 
    const [ _b14, b15, _b16 ] = $.from_coefficients(
      [2.917412e+0, 1.575290e+0, 5.751814e-1],
      [3.629118e+0, -9.112722e-1, 1.042291e+0],
      [4.916389e+0, 2.862149e+0, 7.84485]
    )
    const b14 = _b14**b15
    const b16 = _b16**b15
    const b17 = ($.ζ > -1.0) ? (1.0 - 0.3880523 * (($.ζ + 1.0)**2.862149)) : 1.0
    
    const c = b17/($.M.FGB**0.1) + (b16*b17 - b14)/($.M.FGB**(b15 + 0.1))
    $.L.min_He_ = M => $.L.HeI * fit(M)
      ([b14, 0], [c, b15+0.1])
      ([b16, 0], [1, b15])
    $.L.min_He = $.L.min_He_(M)
  }
  
  // (H77, H78)
  {
    // (H77)
    $.L.ZHe_ = M => $.fit
      ([15262, 10.25])
      ([1, 9], [29.54, 7.5], [31.18, 6], [0.0469, 0])
    $.L.ZHe = $.L.ZHe_(M)
    
    // (H78)
    $.R.ZHe_ = M => $.fit
      ([0.2391, 4.6])
      ([1, 4], [0.162, 3], [0.0065, 0])
    $.R.ZHe = $.R.ZHe_(M)
  }
  
  // (H52, H53)
  {
    $._.µ_ = Mc => (M - Mc)/($.M.HeF - Mc)
    const [ b18, b19, b20 ] = $.from_coefficients(
      [5.496045e+1, -1.289968e+1, 6.385758e+0],
      [1.832694e+0, -5.766608e-2, 5.696128e-2],
      [1.211104e+2]
    )
    const α2_ = Mc => 
      (b18 + $.L.ZHe_(Mc) 
      - $.L.min_He_(M)) 
      / ($.L.min_He_($.M.HeF) - $.L.ZHe_(Mc))
      
    $.L.ZAHB__ = M => Mc => $.L.ZHe_(Mc) 
      + ((1 + b20) / (1 + b20*($._.µ_(Mc)**1.6479)))
      * (b18 * ($._.µ_(Mc)**b19)) / (1 + α2_(M) * exp(15 * (M - $.M.HeF)))
    $.L.ZAHB_ = $.L.ZAHB__(M)
  }
  
  // (H55)
  { 
    const [ _b24, b25, _b27, b28 ] = $.from_coefficients(
      [1.609901e+1, 7.391573e+0, 2.277010e+1, 8.334227e+0],
      [1.747500e-1, 6.271202e-2, -2.324229e-2, -1.844559e-2],
      [2.752869e+0, 2.729201e-2, 4.996927e-1, 2.496551e-1],
      [3.518506e+0, 1.112440e+0, -4.556216e-1, -2.179426e-1],
    )
    const b24 = _b24**b28
    const b26 = 5.0 - 0.09138012 * (Z**-0.3671407)
    const b27 = _b27**(2*b28)
    
    const B_ = (M) => fit(M)
      ([b24, 1], [b25**b26, b26+b28])
      ([b27, 0], [1, b28])
      
    $._.µ = log10(M/12.0) / log10($.M.FGB/12.0)
    const R1 = B_(M)
    const R2_ = Mc => $.R.GB_($.L.ZAHB_(Mc))
      *((B_($.M.HeF) / $.R.GB_($.L.ZAHB__($.M.HeF)(Mc))) ** $._.µ)

    $.R.mHe_ = Mc => (M > $.M.HeF) ? R1 : R2_(Mc)
  }
  
  // (H59, H60)
  {
    $.L.x_ = Mc => (M < $.M.HeF) ? $.L.ZAHB_(Mc)
    : in_range($.M.HeF, M, $.M.FGB) ? $.L.min_He
    : (M > $.M.FGB) ? $.L.HeI
    : 0.0

    $.R.x = (M < $.M.HeF) ? $.R.ZAHB
    : in_range($.M.HeF, M, $.M.FGB) ? $.R.GB_($.L.min_He)
    : (M > $.M.FGB) ? $.R.HeI
    : 0.0
  }
  
  $.L.EHG = (M < $.M.FGB) ? $.L.BGB : $.L.HeI
  $.R.EHG = (M < $.M.FGB) ? $.R.BGB : $.R.HeI
 
  $.bubble = {}
  $.color = ""
  
  stars[id] = $
  star_update(id, 0)
  console.log(JSON.stringify($,"",2))
}

const bubbles = []
const colors = []
const star_update = (id, t) => {
  const $ = stars[id]
  const phase = in_range(0, t, $.t.MS) ? ($.M < 0.7 ? phases.C_MS : phases.MS)
  : in_range($.t.MS, t, $.t.BGB) ? phases.HG
  : in_range($.t.BGB, t, $.t.HeI) ? phases.GB
  : phases.R
  
 // relative time
  
  switch(phase){
    // Main sequence
    case phases.C_MS:
    case phases.MS: {
      const τ = $.τ.MS_(t)
      const τ1 = $.τ.MS_1_(t)
      const τ2 = $.τ.MS_2_(t)
      
      $.L.MS = $.L.MS_(τ, τ1, τ2)
      $.R.MS = $.R.MS_(τ, τ1, τ2)

      $.L.now = $.L.MS
      $.R.now = $.R.MS
      break
    }
    
    // Hertzsprung gap
    case phases.HG: {
      const τ = $.τ.HG_(t)
      
      $.L.HG = $.L.HG_(τ)
      $.R.HG = $.R.HG_(τ)
      $.Mc.HG = $.Mc.HG_(τ)

      $.L.now = $.L.HG
      $.R.now = $.R.HG
      break
    }
    case phases.GB: {
      const τ = $.τ.GB_(t)
      console.log(τ)

      $.L.GB = $.L.GB_(τ)
      $.R.GB = $.R.GB_($.L.GB)   
      $.Mc.GB = $.Mc.GB_(t, τ)
      
      $.R.now = $.R.GB
      $.L.now = $.L.GB
      break
    }
    default: {
      $.R.now = $.R.ZAMS
      $.L.now = $.L.ZAMS
      break
    }
  }
  //console.log(JSON.stringify($.t,"",2))
 
  //if(t * 1e-10 > $.M.ZAMS**-2.5) $.R.now = 0
  $.T.now = radius_lum_to_temp($.R.now, $.L.now)
  $.color = temp_to_col($.T.now)

  $.bubble.x = $.T.now
  $.bubble.y = $.L.now
  $.bubble.r = $.R.now*4
  
  bubbles[id] = $.bubble
  colors[id] = $.color
}

for(let i = 0; i < 100; i++){
  const mass = random_range(min_mass, max_mass)
  
  // Reject unlikely masses
  const test_mass = random_range(min_mass, max_mass)
  //if(initial_mass_function(mass) < initial_mass_function(test_mass)) continue
  
  const metallicity = 0.02
  
  star_init(i, mass, metallicity)
}


Chart.defaults.color = '#ccc'
Chart.defaults.borderColor = '#444'
Chart.defaults.maintainAspectRatio = false

const chart = new Chart(canvas, {
  type: 'bubble',
  data: {
    datasets: [{
      label: 'Stars',
      data: bubbles,
      backgroundColor: colors,
      borderWidth: 1
    }]
  },
  options: {
    clip: false,
    animation: { duration: 0 },
    borderColor: "white",
    scales: {
      x: {
        type: 'linear',
        title: { display, text: 'Surface temperature (Kelvins)' },
        position: 'top',
        min: max_temp, max: min_temp,
        reverse: true,
        grid: { drawOnChartArea: false },
      },
      x1: {
        type: 'linear',
        title: { display, text: 'Blue light versus visible light (B−V index)' },
        position: 'bottom',
        min: min_bv, max: max_bv,
        grid: { drawOnChartArea: true },
      },
      y: {
        type: 'logarithmic',
        title: { display, text: 'Luminosity in Suns eL⊙,' },
        display: true,
        position: 'right',
        min: min_sol_lum, max: max_sol_lum,
        grid: { drawOnChartArea: false },
      },
      y1: {
        type: 'linear',
        position: 'left',
        title: { display, text: 'Hipparchus’s scale (Absolute magnitude)' },
        min: max_mag, max: min_mag,
        reverse: true,
        grid: { drawOnChartArea: true },
      },
    },
    onClick: (e) => {
        const canvasPosition = Chart.helpers.getRelativePosition(e, chart)

        // Substitute the appropriate scale IDs
        const dataX = chart.scales.x.getValueForPixel(canvasPosition.x)
        const dataY = chart.scales.y.getValueForPixel(canvasPosition.y)
    }
  }
})

const $time = document.getElementById("time")
const draw = (now) => {
  const time = (now - 1000)/10
  $time.value = time.toFixed(0)
  for(const id in stars) {
    star_update(id, time)
  }
  chart.update()
  requestAnimationFrame(draw)
}
requestAnimationFrame(draw)
    </script>
  </body>
</html>
