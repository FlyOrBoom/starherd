<html>
  <head>
    <title>Starherd</title>
    <style>
html, body {
  margin: 0;
  width: 100%;
  height: 100%;
  background: #222;
  color: white;
}
    </style>
  </head>
  <body>
    <canvas id="hr"></canvas>
    <h1>Starherd</h1>
    <p> A stellar evolution visualizer by Xing, based on "Comprehensive analytic formulae for stellar evolution as a function of mass and metallicity" by Hurley, Pols &amp; Tout, and "Zero-age main-seqence radii and luminosities as analytic functions of mass and metallicity" by Eggleton, Fitchett &amp; Tout.</p>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script>
 "use strict"

const canvas = document.getElementById('hr')

// Math
const random_range = (a, b) => a + (b - a) * Math.random()
const in_range = (a, x, b) => (a <= x) && (x <= b)
const log10 = (x) => Math.log(x)/Math.log(10)
const max = (a,b) => Math.max(a,b)
const min = (a,b) => Math.min(a,b)
const int_range = (n) => Array(n).fill(0).map((_, i) => i)

// Constants
const PI = Math.PI
const STEFAN = 5.670374419e-8
const L_sun = 3.86e+26 // watts
const R_sun = 6.9634e+8 // meters

// Conversions
const abs_mag_to_sol_lum = (M) => 
  Math.pow(100, -M/5)
  
const bv_to_temp = (i) => 
  4600 * (1/(0.92*i + 1.7) + 1/(0.92*i + 0.62))
  
const sol_radius_and_sol_lum_to_temp = (R, L) => 
  ( L*L_sun / ((4*PI*R*R*R_sun*R_sun) * STEFAN) ) ** (1/4)
  
const temp_to_col = (T) => {
  const blackbody = [
   {temp:1000,col:"#ff3800"},{temp:1200,col:"#ff5300"},{temp:1400,col:"#ff6500"},{temp:1600,col:"#ff7300"},{temp:1800,col:"#ff7e00"},{temp:2000,col:"#ff8912"},{temp:2200,col:"#ff932c"},{temp:2400,col:"#ff9d3f"},{temp:2600,col:"#ffa54f"},{temp:2800,col:"#ffad5e"},{temp:3000,col:"#ffb46b"},{temp:3200,col:"#ffbb78"},{temp:3400,col:"#ffc184"},{temp:3600,col:"#ffc78f"},{temp:3800,col:"#ffcc99"},{temp:4000,col:"#ffd1a3"},{temp:4200,col:"#ffd5ad"},{temp:4400,col:"#ffd9b6"},{temp:4600,col:"#ffddbe"},{temp:4800,col:"#ffe1c6"},{temp:5000,col:"#ffe4ce"},{temp:5200,col:"#ffe8d5"},{temp:5400,col:"#ffebdc"},{temp:5600,col:"#ffeee3"},{temp:5800,col:"#fff0e9"},{temp:6000,col:"#fff3ef"},{temp:6200,col:"#fff5f5"},{temp:6400,col:"#fff8fb"},{temp:6600,col:"#fef9ff"},{temp:6800,col:"#f9f6ff"},{temp:7000,col:"#f5f3ff"},{temp:7200,col:"#f0f1ff"},{temp:7400,col:"#edefff"},{temp:7600,col:"#e9edff"},{temp:7800,col:"#e6ebff"},{temp:8000,col:"#e3e9ff"},{temp:8200,col:"#e0e7ff"},{temp:8400,col:"#dde6ff"},{temp:8600,col:"#dae4ff"},{temp:8800,col:"#d8e3ff"},{temp:9000,col:"#d6e1ff"},{temp:9200,col:"#d3e0ff"},{temp:9400,col:"#d1dfff"},{temp:9600,col:"#cfddff"},{temp:9800,col:"#cedcff"},{temp:10000,col:"#ccdbff"},{temp:10200,col:"#cadaff"},{temp:10400,col:"#c9d9ff"},{temp:10600,col:"#c7d8ff"},{temp:10800,col:"#c6d8ff"},{temp:11000,col:"#c4d7ff"},{temp:11200,col:"#c3d6ff"},{temp:11400,col:"#c2d5ff"},{temp:11600,col:"#c1d4ff"},{temp:11800,col:"#c0d4ff"},{temp:12000,col:"#bfd3ff"},{temp:12200,col:"#bed2ff"},{temp:12400,col:"#bdd2ff"},{temp:12600,col:"#bcd1ff"},{temp:12800,col:"#bbd1ff"},{temp:13000,col:"#bad0ff"},{temp:13200,col:"#b9d0ff"},{temp:13400,col:"#b8cfff"},{temp:13600,col:"#b7cfff"},{temp:13800,col:"#b7ceff"},{temp:14000,col:"#b6ceff"},{temp:14200,col:"#b5cdff"},{temp:14400,col:"#b5cdff"},{temp:14600,col:"#b4ccff"},{temp:14800,col:"#b3ccff"},{temp:15000,col:"#b3ccff"},{temp:15200,col:"#b2cbff"},{temp:15400,col:"#b2cbff"},{temp:15600,col:"#b1caff"},{temp:15800,col:"#b1caff"},{temp:16000,col:"#b0caff"},{temp:16200,col:"#afc9ff"},{temp:16400,col:"#afc9ff"},{temp:16600,col:"#afc9ff"},{temp:16800,col:"#aec9ff"},{temp:17000,col:"#aec8ff"},{temp:17200,col:"#adc8ff"},{temp:17400,col:"#adc8ff"},{temp:17600,col:"#acc7ff"},{temp:17800,col:"#acc7ff"},{temp:18000,col:"#acc7ff"},{temp:18200,col:"#abc7ff"},{temp:18400,col:"#abc6ff"},{temp:18600,col:"#aac6ff"},{temp:18800,col:"#aac6ff"},{temp:19000,col:"#aac6ff"},{temp:19200,col:"#a9c6ff"},{temp:19400,col:"#a9c5ff"},{temp:19600,col:"#a9c5ff"},{temp:19800,col:"#a9c5ff"},{temp:20000,col:"#a8c5ff"},{temp:20200,col:"#a8c5ff"},{temp:20400,col:"#a8c4ff"},{temp:20600,col:"#a7c4ff"},{temp:20800,col:"#a7c4ff"},{temp:21000,col:"#a7c4ff"},{temp:21200,col:"#a7c4ff"},{temp:21400,col:"#a6c3ff"},{temp:21600,col:"#a6c3ff"},{temp:21800,col:"#a6c3ff"},{temp:22000,col:"#a6c3ff"},{temp:22200,col:"#a5c3ff"},{temp:22400,col:"#a5c3ff"},{temp:22600,col:"#a5c3ff"},{temp:22800,col:"#a5c2ff"},{temp:23000,col:"#a4c2ff"},{temp:23200,col:"#a4c2ff"},{temp:23400,col:"#a4c2ff"},{temp:23600,col:"#a4c2ff"},{temp:23800,col:"#a4c2ff"},{temp:24000,col:"#a3c2ff"},{temp:24200,col:"#a3c1ff"},{temp:24400,col:"#a3c1ff"},{temp:24600,col:"#a3c1ff"},{temp:24800,col:"#a3c1ff"},{temp:25000,col:"#a3c1ff"},{temp:25200,col:"#a2c1ff"},{temp:25400,col:"#a2c1ff"},{temp:25600,col:"#a2c1ff"},{temp:25800,col:"#a2c1ff"},{temp:26000,col:"#a2c0ff"},{temp:26200,col:"#a2c0ff"},{temp:26400,col:"#a1c0ff"},{temp:26600,col:"#a1c0ff"},{temp:26800,col:"#a1c0ff"},{temp:27000,col:"#a1c0ff"},{temp:27200,col:"#a1c0ff"},{temp:27400,col:"#a1c0ff"},{temp:27600,col:"#a1c0ff"},{temp:27800,col:"#a0c0ff"},{temp:28000,col:"#a0bfff"},{temp:28200,col:"#a0bfff"},{temp:28400,col:"#a0bfff"},{temp:28600,col:"#a0bfff"},{temp:28800,col:"#a0bfff"},{temp:29000,col:"#a0bfff"},{temp:29200,col:"#a0bfff"},{temp:29400,col:"#9fbfff"},{temp:29600,col:"#9fbfff"},{temp:29800,col:"#9fbfff"},{temp:1e10,col:"#9fbfff"}
  ]
  return blackbody.find(({temp})=> temp > T).col
}

// Probability density function of stars' initial masses
const initial_mass_function = M => (
  in_range(0.08, M, 0.50) ? 0.035 * Math.pow(M, -1.3)
  : in_range (0.50, M, 1.00) ? 0.019 * Math.pow(M, -2.2)
  : in_range (1.00, M, 100) ? 0.019 * Math.pow(M, -2.7)
  : 0
)

// Zeta function of metallicity Z
const phases = {
  C_MS: { name: "Main sequence below 0.7 M", index: 0, },
  MS: { name: "Main sequence above 0.7 M", index: 1, },
  HG: { name: "Hertzsprung Gap", index: 2, },
  GB: { name: "First Giant Branch", index: 3, },
  CHe_B: { name: "Core Helium Burning", index: 4, },
  EA_GB: { name: "Early Asymptotic Giant Branch", index: 5, },
  TAP_GB: { name: "Thermally Pulsating Asymptotic Giant Branch", index: 6, },
  He_MS: { name: "Naked Helium Star Main Sequence", index: 7, },
  He_HG: { name: "Naked Helium Star Hertzsprung Gap", index: 8, },
  He_GB: { name: "Naked Helium Star Giant Branch", index: 9, },
  He_WD: { name: "Helium White Dwarf", index: 10, },
  CO_WD: { name: "Carbon/Oxygen White Dwarf", index: 11, },
  ONe_WD: { name: "Oxygen/Neon White Dwarf", index: 12, },
  NS: { name: "Neutron Star", index: 13, },
  BH: { name: "Black Hole", index: 14, },
  R: { name: "massless remnant", index: 15, },
}

const polynomial = coefficients => x => 
  coefficients.reduce((sum, coefficient, degree) => 
    sum + coefficient * (x**degree)
  , 0)

const rational = (...pairs) => x =>
  pairs.reduce((sum, [coefficient, exponent]) => 
    sum + coefficient * (x ** exponent)
  , 0)

const fit = (...numerator) => (...denominator) => x =>
  rational(...numerator)(x) / rational(...denominator)(x)

let min_bv = -0.5, max_bv = +3
let min_temp = bv_to_temp(min_bv), max_temp = bv_to_temp(max_bv)

let min_mag = +10, max_mag = -10
let min_sol_lum = abs_mag_to_sol_lum(min_mag), max_sol_lum = abs_mag_to_sol_lum(max_mag)

let min_mass = 0.1, max_mass = 10

const display = true

const bubble_config = {
  count: 7,
  rmin: 5,
  rmax: 15,
  min: 0,
  max: 100
}

const stars = {}

const star_to_bubble = ({T,L,R}) => ({ 
  x: T, 
  y: L, 
  r: R*2
})


const star_init = (id, M, Z) => {
  const $ = { id, M, Z }
  
  $.ζ = log10(Z)
  
  // Zero-age main sequence mass and radius
  
  {
    const coefficients = [
      [ 1.715359, 0.62246212, -0.92557761, -1.16996966, -0.30631491 ], 
      [ 6.597788, -0.42450044, -12.13339427, -10.73509484, -2.51487077 ],
      [ 10.08855, -7.11727086, -31.67119479, -24.24848322, -5.33608972 ],
      [ 1.012495, 0.3269969, -0.00923418, -0.03876858, -0.0041275 ],
      [ 0.07490166, 0.02410413, 0.07233664, 0.03040467, 0.00197741 ],
      [ 0.01077422, 0, 0, 0, 0 ],
      [ 3.082234, 0.9447205, -2.15200882, -2.49219496, -0.63848738 ],
      [ 17.84778, -7.4534569, -48.96066856, -40.05386135, -9.09331816 ],
      [ 0.00022582, -0.00186899, 0.00388783, 0.00142402, -0.00007671 ],
    ]
    const p = n => polynomial(coefficients[n])($.ζ)
    const [ a1, a2, a3, a4, a5, a6, a7, a8, a9 ] = int_range(9).map(p) 
    const R = ( a1*(M**2.5) + a2*(M**6.5) + a3*(M**11) + a4*(M**19) + a5*(M**19.5) )
    / (  a6 + a7*(M**2) + a8*(M**8.5) + (M**18.5) + a9*(M**19.5) )
    $.R_ZAMS = R
  }
  
  {
    const coefficients = [
      [ 0.3970417, -0.32913574, 0.34776688, 0.37470851, 0.09011915 ],
      [ 8.527626, -24.41225973, 56.43597107, 37.06152575, 5.4562406 ],
      [ 0.00025546, -0.00123461, -0.00023246, 0.00045519, 0.00016176 ],
      [ 5.432889, -8.62157806, 13.44202049, 14.51584135, 3.39793084 ],
      [ 5.563579, -10.32345224, 19.4432298, 18.97361347, 4.16903097 ],
      [ 0.7886606, -2.90870942, 6.54713531, 4.05606657, 0.53287322 ],
      [ 0.00586685, -0.01704237, 0.03872348, 0.02570041, 0.00383376 ]
    ]
    const p = n => polynomial(coefficients[n])($.ζ)
    const [ a1, a2, a3, a4, a5, a6, a7 ] = int_range(7).map(p)
    $.L_ZAMS = fit
    ([a1, 5.5], [a2, 11])
    ([a3, 0], [1, 3], [a4, 5], [a5, 7], [a6, 8], [a7, 9.5])
    (M)
  }
  
  
  // the initial mass above which a hook appears in the main-sequence
  $.M_hook = 1.0185 + 0.16015*$.ζ + 0.0892*$.ζ*$.ζ
  
  // the maximum initial mass for which He ignites degenerately in a helium flash
  $.M_HeF = 1.995 + 0.25*$.ζ + 0.087*$.ζ*$.ζ
  
  // the maximum initial mass for which He ignites on the first giant branch
  $.M_FGB = 13.048 * (($.Z/0.02)**0.06) / (1 + 0.0012*((0.02/$.Z)**1.27))
  
  // where the mass of the convective envelope MCE first exceeds a set fraction of the envelope mass ME
  $.ratio_CE_E = (M < $.M_HeF) ? (2/5) : (1/3)
  
  {
    const coefficients = [
      [1.593890, 2.053038, 1.231226, 2.327785, 0],
      [2.706708, 1.483131, 5.772723, 7.411230, 0],
      [1.466143, -1.048442, -6.795374, -1.391127, 0],
      [4.141960, 4.564888, 2.958542, 5.571483, 0],
      [3.426349, 0,0,0,0]
    ]
    const p = n => polynomial(coefficients[n])($.ζ)
    const [ a1, a2, a3, a4, a5 ] = int_range(5).map(p)
    $.t_BGB = $.t_HeI = fit
    ([a1, 0], [a2, 4], [a3, 5.5], [1, 7])
    ([a4, 2], [a5, 7])
    (M)
  }
  
  {
    const coefficients = [
      [1.949814, 1.758178, -6.008212, -4.470533],
      [4.903830, 0, 0, 0],
      [5.212154, 3.166411, -2.750074, -2.271549],
      [1.312179, -3.294936, 9.231860, 2.610989],
      [8.073972, 0, 0, 0],
    ]
    const p = n => polynomial(coefficients[n])($.ζ)
    const [ a6, a7, a8, a9, a10 ] = int_range(5).map(p)
    const µ = max(0.5, 1 - 0.01 * max(a6 / (M**a7), a8 + a9/(M**a10)))
    const x = max(0.95, min(0.95 - 0.03*($.ζ + 0.30103), 0.99))
    $.t_MS = max(µ * $.t_BGB, x * $.t_BGB)
  }
  
  {
    const coefficients = [
      [1.031538, -2.434480, 7.732821, 6.460705, 1.374484],
      [1.043715, -1.577474, -5.168234, -5.596506, -1.299394],
      [7.859573, -8.542048, -2.642511, -9.585707],
      [3.858911, 2.459681, -7.630093, -3.486057, -4.861703],
      [2.888720, 2.952979, 1.850341, 3.797254],
      [7.196580, 5.613746, 3.805871, 8.398728],
    ]
    const p = n => polynomial(coefficients[n])($.ζ)
    const [ _a11, _a12, a13, a14, a15, a16 ] = int_range(6).map(p)
    const a11 = _a11 * a14
    const a12 = _a12 * a14
    $.L_TMS = fit
    ([a11, 3], [a12, 4], [a13, a16 + 1.8])
    ([a14, 0], [a15, 5], [1, a16])
    (M)
  }
  $.L_EHG = (M < $.M_FGB) ? $.L_BGB : $.L_HeI
  
  $.R = $.R_ZAMS
  $.L = $.L_ZAMS
  $.T = sol_radius_and_sol_lum_to_temp($.R, $.L)
  
  $.bubble = star_to_bubble($)
  $.color = temp_to_col($.T)

  stars[id] = $
}

const star_update = (id, t) => {
  const $ = stars[id]
  const phase = in_range(0, t, $.t_MS) ? ($.M < 0.7 ? phases.C_MS : phases.MS)
  : in_range($.t_MS, t, $.t_BGB) ? phases.HG
  : in_range($.t_BGB, t, 1000) ? phases.GB
  : phases.R
  if(phase === phases.GB) $.bubble.r = $.R*20
}

for(let i = 0; i < 50; i++){
  const mass = random_range(min_mass, max_mass)
  
  // Reject unlikely masses
  const test_mass = random_range(min_mass, max_mass)
  //if(initial_mass_function(mass) < initial_mass_function(test_mass)) continue
  
  const metallicity = 0.02
  
  star_init(i, mass, metallicity)
}


Chart.defaults.color = '#ccc'
Chart.defaults.borderColor = '#444'
Chart.defaults.maintainAspectRatio = false

const chart = new Chart(canvas, {
  type: 'bubble',
  data: {
    datasets: [{
      label: 'Stars',
      data: Object.values(stars).map(s=>s.bubble),
      backgroundColor: Object.values(stars).map(s=>s.color),
      borderWidth: 1
    }]
  },
  options: {
    scales: {
      x: {
        type: 'linear',
        title: { display, text: 'Surface temperature (Kelvins)' },
        position: 'top',
        min: max_temp, max: min_temp,
        reverse: true,
        grid: { drawOnChartArea: false },
      },
      x1: {
        type: 'linear',
        title: { display, text: 'Blue light versus visible light (B−V index)' },
        position: 'bottom',
        min: min_bv, max: max_bv,
        grid: { drawOnChartArea: true },
      },
      y: {
        type: 'logarithmic',
        title: { display, text: 'Luminosity in Suns (L⊙)' },
        display: true,
        position: 'right',
        min: min_sol_lum, max: max_sol_lum,
        grid: { drawOnChartArea: false },
      },
      y1: {
        type: 'linear',
        position: 'left',
        title: { display, text: 'Hipparchus’s scale (Absolute magnitude)' },
        min: max_mag, max: min_mag,
        reverse: true,
        grid: { drawOnChartArea: true },
      },
    }
  }
})


const draw = (now) => {
  for(const id in stars) {
    star_update(id, now/1000 - 3)
  }
  chart.update()
  requestAnimationFrame(draw)
}
requestAnimationFrame(draw)
    </script>
  </body>
</html>
